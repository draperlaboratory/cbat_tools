(***************************************************************************)
(*                                                                         *)
(*  Copyright (C) 2018/2019 The Charles Stark Draper Laboratory, Inc.      *)
(*                                                                         *)
(*  This file is provided under the license found in the LICENSE file in   *)
(*  the top-level directory of this project.                               *)
(*                                                                         *)
(*  This work is funded in part by ONR/NAWC Contract N6833518C0107.  Its   *)
(*  content does not necessarily reflect the position or policy of the US  *)
(*  Government and no official endorsement should be inferred.             *)
(*                                                                         *)
(***************************************************************************)

(**

   This module creates utilities to create preconditions for comparing
   BIR blocks and subroutines.

   Usage typically involves creating a new (abstract) {!Environment.t}
   value, a Z3 context and a {!Environment.var_gen} using the utility
   functions.

   The API returns a pair of {!comparator}s which are used to create a
   postcondition and hypothesis in that order. These should then be passed
   into {!compare_subs} in order to run the comparative analysis.

   The resulting precondition can then be tested for satisfiability or
   provability using the Z3 Solver module using the {!precondition}
   module utilities.

*)

module Env = Environment

module Constr = Constraint

(** The type of functions that generate a postcondition or hypothesis for
    comparative analysis. Also updates the environments as needed. *)
type comparator

(** Compare two blocks by composition: given a set of common
    input and output variables, return a precondition which is provable
    only if (modulo soundness bugs) the subroutines have equal output
    variables given equal input variables. *)
val compare_blocks
  :  input:Bap.Std.Var.Set.t
  -> output:Bap.Std.Var.Set.t
  -> original:(Bap.Std.Blk.t * Env.t)
  -> modified:(Bap.Std.Blk.t * Env.t)
  -> smtlib_post:string
  -> smtlib_hyp:string
  -> Constr.t * Env.t * Env.t

(** Compare two subroutines by composition: given the lists of postconditions
    and hypotheses generated by the API below. *)
val compare_subs
  :  postconds:(comparator list)
  -> hyps:(comparator list)
  -> original:(Bap.Std.Sub.t * Env.t)
  -> modified:(Bap.Std.Sub.t * Env.t)
  -> Constr.t * Env.t * Env.t

(** Compare two subroutines by composition for equality of return
    values:

    Given a set of common input and output variables, return a postcondition
    and hypothesis that, when passed to [compare_subs], will generate a
    precondition which is provable only if (modulo soundness bugs) the
    subroutines have equal output variables given equal input
    variables. *)
val compare_subs_eq
  :  input:Bap.Std.Var.Set.t
  -> output:Bap.Std.Var.Set.t
  -> comparator * comparator

(** Compare two subroutines by composition for an empty postcondition:

    Given two subroutines and environments, return a postcondition
    and hypothesis that, when passed to [compare_subs], will generate a
    precondition which is provable only if (modulo soundness bugs) the VCs generated
    by the hooks provided by the environment are satisfied. *)
val compare_subs_empty : unit -> comparator * comparator

(** Compare two subroutines by composition for an empty
    postcondition:

    Given two subroutines and environments, return a postcondition
    and hypothesis that, when passed to [compare_subs], will generate a
    precondition which is provable only if (modulo soundness bugs), for equal
    inputs, the VCs generated by the hooks provided by the environment
    are satisfied. *)
val compare_subs_empty_post : unit -> comparator * comparator

(** Compare two subs by composition for an empty postcondition:

    Give two subroutines and environments, return a postcondition
    and hypothesis that, when passed to [compare_subs], will generate a
    precondition which is provable only if (module soundness bugs) the VCs generated
    by the hooks provided by the environment are satisfied, given that the
    stack pointer is pointing to the stack at the beginning of the subroutine. *)
val compare_subs_sp : unit -> comparator * comparator

(** Compare two subroutines by composition for conservation of function calls:

    Given two subroutines and environments, return a postcondition
    and hypothesis that, when passed to [compare_subs], will generate a
    precondition which is provable only if (modulo soundness bugs) every call made by
    the original subroutine is made by the modified one, given equal variables
    on input. *)
val compare_subs_fun : unit -> comparator * comparator

(** Compare two subroutines by composition based on the postcondition
    specified from the smtlib2 string.

    Give two subroutines and environments, return a postcondition
    and hypothesis that, when passed to [compare_subs], will generate a
    precondition which is provable only if (module soundness bugs) the
    postcondition from the smtlib2 string is satisfiable, given the
    hypothesis specified from the smtlib2 string. *)
val compare_subs_smtlib
  :  smtlib_post:string
  -> smtlib_hyp:string
  -> comparator * comparator

(** [mk_smtlib2_compare] builds a constraint out of an smtlib2 string that can be used
    as a comparison predicate between an original and modified binary. *)
val mk_smtlib2_compare : Env.t -> Env.t -> string -> Constr.t
