
Disassembly of section .plt.got

4003d0: <__gmon_start__>
4003d0:
4003d0: jmpq *0x200c22(%rip)
{
  special
  (external:__gmon_start__@external)
}

Disassembly of section .text

4003e0: <_start>
4003e0:
4003e0: xorl %ebp, %ebp
{
  RBP := 0
  AF := unknown[bits]:u1
  ZF := 1
  PF := 1
  OF := 0
  CF := 0
  SF := 0
}
4003e2: movq %rdx, %r9
{
  R9 := RDX
}
4003e5: popq %rsi
{
  RSI := mem[RSP, el]:u64
  RSP := RSP + 8
}
4003e6: movq %rsp, %rdx
{
  RDX := RSP
}
4003e9: andq $-0x10, %rsp
{
  RSP := RSP & 0xFFFFFFFFFFFFFFF0
  OF := 0
  CF := 0
  AF := unknown[bits]:u1
  PF :=
    ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSP]
  ZF := 0 = RSP
}
4003ed: pushq %rax
{
  #20 := RAX
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #20
}
4003ee: pushq %rsp
{
  #21 := RSP
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #21
}
4003ef: movq $0x400570, %r8
{
  R8 := 0x400570
}
4003f6: movq $0x400500, %rcx
{
  RCX := 0x400500
}
4003fd: movq $0x4004e1, %rdi
{
  RDI := 0x4004E1
}
400404: callq -0x49
{
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- 0x400409
  jmp 0x4003C0
}
400409:
400409: hlt
{
  
}
40040a: nopw (%rax,%rax)
{
  
}

400410: <deregister_tm_clones>
400410:
400410: movl $0x601037, %eax
{
  RAX := 0x601037
}
400415: pushq %rbp
{
  #22 := RBP
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #22
}
400416: subq $0x601030, %rax
{
  #23 := RAX
  RAX := RAX - 0x601030
  CF := #23 < 0x601030
  OF := high:1[(#23 ^ 0x601030) & (#23 ^ RAX)]
  AF := 0x10 = (0x10 & (RAX ^ #23 ^ 0x601030))
  PF :=
    ~low:1[let $1 = RAX >> 4 ^ RAX in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RAX]
  ZF := 0 = RAX
}
40041c: cmpq $0xe, %rax
{
  #26 := RAX - 0xE
  CF := RAX < 0xE
  OF := high:1[(RAX ^ 0xE) & (RAX ^ #26)]
  AF := 0x10 = (0x10 & (#26 ^ RAX ^ 0xE))
  PF :=
    ~low:1[let $1 = #26 >> 4 ^ #26 in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[#26]
  ZF := 0 = #26
}
400420: movq %rsp, %rbp
{
  RBP := RSP
}
400423: jbe 0x1b
{
  if (CF | ZF) {
    jmp 0x400440
  }
}
400425:
400425: movl $0x0, %eax
{
  RAX := 0
}
40042a: testq %rax, %rax
{
  #89 := RAX
  OF := 0
  CF := 0
  AF := unknown[bits]:u1
  PF :=
    ~low:1[let $1 = #89 >> 4 ^ #89 in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[#89]
  ZF := 0 = #89
}
40042d: je 0x11
{
  if (ZF) {
    jmp 0x400440
  }
}
40042f:
40042f: popq %rbp
{
  RBP := mem[RSP, el]:u64
  RSP := RSP + 8
}
400430: movl $0x601030, %edi
{
  RDI := 0x601030
}
400435: jmpq *%rax
{
  jmp RAX
}
400440:
400440: popq %rbp
{
  RBP := mem[RSP, el]:u64
  RSP := RSP + 8
}
400441: retq
{
  #28 := mem[RSP, el]:u64
  RSP := RSP + 8
  jmp #28
}

400450: <register_tm_clones>
400450:
400450: movl $0x601030, %esi
{
  RSI := 0x601030
}
400455: pushq %rbp
{
  #29 := RBP
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #29
}
400456: subq $0x601030, %rsi
{
  #30 := RSI
  RSI := RSI - 0x601030
  CF := #30 < 0x601030
  OF := high:1[(#30 ^ 0x601030) & (#30 ^ RSI)]
  AF := 0x10 = (0x10 & (RSI ^ #30 ^ 0x601030))
  PF :=
    ~low:1[let $1 = RSI >> 4 ^ RSI in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSI]
  ZF := 0 = RSI
}
40045d: sarq $0x3, %rsi
{
  #33 := RSI
  RSI := RSI ~>> 3
  CF := high:1[#33 << 0x3D]
  SF := high:1[RSI]
  ZF := 0 = RSI
  PF :=
    ~low:1[let $1 = RSI >> 4 ^ RSI in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  AF := unknown[bits]:u1
  OF := unknown[bits]:u1
}
400461: movq %rsp, %rbp
{
  RBP := RSP
}
400464: movq %rsi, %rax
{
  RAX := RSI
}
400467: shrq $0x3f, %rax
{
  #35 := RAX
  RAX := RAX >> 0x3F
  CF := high:1[#35 << 1]
  SF := high:1[RAX]
  ZF := 0 = RAX
  PF :=
    ~low:1[let $1 = RAX >> 4 ^ RAX in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  AF := unknown[bits]:u1
  OF := unknown[bits]:u1
}
40046b: addq %rax, %rsi
{
  #37 := RSI
  #38 := RAX
  RSI := RSI + #38
  CF := RSI < #37
  OF := high:1[#37] = high:1[#38] & (high:1[#37] | high:1[RSI]) &
    ~(high:1[#37] & high:1[RSI])
  AF := 0x10 = (0x10 & (RSI ^ #37 ^ #38))
  PF :=
    ~low:1[let $1 = RSI >> 4 ^ RSI in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSI]
  ZF := 0 = RSI
}
40046e: sarq %rsi
{
  #40 := RSI
  RSI := RSI ~>> 1
  CF := high:1[#40 << 0x3F]
  SF := high:1[RSI]
  ZF := 0 = RSI
  PF :=
    ~low:1[let $1 = RSI >> 4 ^ RSI in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  AF := unknown[bits]:u1
  OF := 0
}
400471: je 0x15
{
  if (ZF) {
    jmp 0x400488
  }
}
400473:
400473: movl $0x0, %eax
{
  RAX := 0
}
400478: testq %rax, %rax
{
  #87 := RAX
  OF := 0
  CF := 0
  AF := unknown[bits]:u1
  PF :=
    ~low:1[let $1 = #87 >> 4 ^ #87 in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[#87]
  ZF := 0 = #87
}
40047b: je 0xb
{
  if (ZF) {
    jmp 0x400488
  }
}
40047d:
40047d: popq %rbp
{
  RBP := mem[RSP, el]:u64
  RSP := RSP + 8
}
40047e: movl $0x601030, %edi
{
  RDI := 0x601030
}
400483: jmpq *%rax
{
  jmp RAX
}
400488:
400488: popq %rbp
{
  RBP := mem[RSP, el]:u64
  RSP := RSP + 8
}
400489: retq
{
  #42 := mem[RSP, el]:u64
  RSP := RSP + 8
  jmp #42
}

400490: <__do_global_dtors_aux>
400490:
400490: cmpb $0x0, 0x200b99(%rip)
{
  #43 := mem[0x601030]
  CF := mem[0x601030] < 0
  OF := high:1[mem[0x601030] & (mem[0x601030] ^ #43)]
  AF := 0x10 = (0x10 & (#43 ^ mem[0x601030]))
  PF :=
    ~low:1[let $1 = #43 >> 4 ^ #43 in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[#43]
  ZF := 0 = #43
}
400497: jne 0x11
{
  if (~ZF) {
    jmp 0x4004AA
  }
}
400499:
400499: pushq %rbp
{
  #86 := RBP
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #86
}
40049a: movq %rsp, %rbp
{
  RBP := RSP
}
40049d: callq -0x92
{
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- 0x4004A2
  jmp 0x400410
}
4004a2:
4004a2: popq %rbp
{
  RBP := mem[RSP, el]:u64
  RSP := RSP + 8
}
4004a3: movb $0x1, 0x200b86(%rip)
{
  mem := mem with [0x601030] <- 1
}
4004aa:
4004aa: rep  retq
{
  #45 := mem[RSP, el]:u64
  RSP := RSP + 8
  jmp #45
}

4004b0: <frame_dummy>
4004b0:
4004b0: movl $0x600e20, %edi
{
  RDI := 0x600E20
}
4004b5: cmpq $0x0, (%rdi)
{
  #46 := mem[RDI, el]:u64
  CF := mem[RDI, el]:u64 < 0
  OF := high:1[mem[RDI, el]:u64 & (mem[RDI, el]:u64 ^ #46)]
  AF := 0x10 = (0x10 & (#46 ^ mem[RDI, el]:u64))
  PF :=
    ~low:1[let $1 = #46 >> 4 ^ #46 in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[#46]
  ZF := 0 = #46
}
4004b9: jne 0x5
{
  if (~ZF) {
    jmp 0x4004C0
  }
}
4004bb:
4004bb: jmp -0x6d
{
  jmp 0x400450
}
4004c0:
4004c0: movl $0x0, %eax
{
  RAX := 0
}
4004c5: testq %rax, %rax
{
  #48 := RAX
  OF := 0
  CF := 0
  AF := unknown[bits]:u1
  PF :=
    ~low:1[let $1 = #48 >> 4 ^ #48 in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[#48]
  ZF := 0 = #48
}
4004c8: je -0xf
{
  if (ZF) {
    jmp 0x4004BB
  }
}
4004ca:
4004ca: pushq %rbp
{
  #50 := RBP
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #50
}
4004cb: movq %rsp, %rbp
{
  RBP := RSP
}
4004ce: callq *%rax
{
  #51 := RAX
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- 0x4004D0
  jmp #51
}
4004d0:
4004d0: popq %rbp
{
  RBP := mem[RSP, el]:u64
  RSP := RSP + 8
}
4004d1: jmp -0x86
{
  jmp 0x400450
}

4004d6: <g>
4004d6:
4004d6: pushq %rbp
{
  #52 := RBP
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #52
}
4004d7: movq %rsp, %rbp
{
  RBP := RSP
}
4004da: movl $0x4, %eax
{
  RAX := 4
}
4004df: popq %rbp
{
  RBP := mem[RSP, el]:u64
  RSP := RSP + 8
}
4004e0: retq
{
  #53 := mem[RSP, el]:u64
  RSP := RSP + 8
  jmp #53
}

4004e1: <main>
4004e1:
4004e1: pushq %rbp
{
  #54 := RBP
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #54
}
4004e2: movq %rsp, %rbp
{
  RBP := RSP
}
4004e5: subq $0x8, %rsp
{
  #55 := RSP
  RSP := RSP - 8
  CF := #55 < 8
  OF := high:1[(#55 ^ 8) & (#55 ^ RSP)]
  AF := 0x10 = (0x10 & (RSP ^ #55 ^ 8))
  PF :=
    ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSP]
  ZF := 0 = RSP
}
4004e9: movl %edi, -0x4(%rbp)
{
  mem := mem with [RBP - 4, el]:u32 <- low:32[RDI]
}
4004ec: movl $0x0, %eax
{
  RAX := 0
}
4004f1: callq -0x20
{
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- 0x4004F6
  jmp 0x4004D6
}
4004f6:
4004f6: leave
{
  RSP := RBP
  RBP := mem[RSP, el]:u64
  RSP := RSP + 8
}
4004f7: retq
{
  #58 := mem[RSP, el]:u64
  RSP := RSP + 8
  jmp #58
}

400500: <__libc_csu_init>
400500:
400500: pushq %r15
{
  #59 := R15
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #59
}
400502: pushq %r14
{
  #60 := R14
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #60
}
400504: movl %edi, %r15d
{
  R15 := pad:64[low:32[RDI]]
}
400507: pushq %r13
{
  #61 := R13
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #61
}
400509: pushq %r12
{
  #62 := R12
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #62
}
40050b: leaq 0x2008fe(%rip), %r12
{
  R12 := 0x600E10
}
400512: pushq %rbp
{
  #63 := RBP
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #63
}
400513: leaq 0x2008fe(%rip), %rbp
{
  RBP := 0x600E18
}
40051a: pushq %rbx
{
  #64 := RBX
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #64
}
40051b: movq %rsi, %r14
{
  R14 := RSI
}
40051e: movq %rdx, %r13
{
  R13 := RDX
}
400521: subq %r12, %rbp
{
  #65 := RBP
  #66 := R12
  RBP := RBP - R12
  CF := #65 < #66
  OF := high:1[(#65 ^ #66) & (#65 ^ RBP)]
  AF := 0x10 = (0x10 & (RBP ^ #65 ^ #66))
  PF :=
    ~low:1[let $1 = RBP >> 4 ^ RBP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RBP]
  ZF := 0 = RBP
}
400524: subq $0x8, %rsp
{
  #68 := RSP
  RSP := RSP - 8
  CF := #68 < 8
  OF := high:1[(#68 ^ 8) & (#68 ^ RSP)]
  AF := 0x10 = (0x10 & (RSP ^ #68 ^ 8))
  PF :=
    ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSP]
  ZF := 0 = RSP
}
400528: sarq $0x3, %rbp
{
  #71 := RBP
  RBP := RBP ~>> 3
  CF := high:1[#71 << 0x3D]
  SF := high:1[RBP]
  ZF := 0 = RBP
  PF :=
    ~low:1[let $1 = RBP >> 4 ^ RBP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  AF := unknown[bits]:u1
  OF := unknown[bits]:u1
}
40052c: callq -0x1a1
{
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- 0x400531
  jmp 0x400390
}
400531:
400531: testq %rbp, %rbp
{
  #73 := RBP
  OF := 0
  CF := 0
  AF := unknown[bits]:u1
  PF :=
    ~low:1[let $1 = #73 >> 4 ^ #73 in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[#73]
  ZF := 0 = #73
}
400534: je 0x20
{
  if (ZF) {
    jmp 0x400556
  }
}
400536:
400536: xorl %ebx, %ebx
{
  RBX := 0
  AF := unknown[bits]:u1
  ZF := 1
  PF := 1
  OF := 0
  CF := 0
  SF := 0
}
400538: nopl (%rax,%rax)
{
  
}
400540:
400540: movq %r13, %rdx
{
  RDX := R13
}
400543: movq %r14, %rsi
{
  RSI := R14
}
400546: movl %r15d, %edi
{
  RDI := pad:64[low:32[R15]]
}
400549: callq *(%r12,%rbx,8)
{
  #80 := mem[R12 + (RBX << 3), el]:u64
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- 0x40054D
  jmp #80
}
40054d:
40054d: addq $0x1, %rbx
{
  #81 := RBX
  RBX := RBX + 1
  CF := RBX < #81
  OF := ~high:1[#81] & (high:1[#81] | high:1[RBX]) &
    ~(high:1[#81] & high:1[RBX])
  AF := 0x10 = (0x10 & (RBX ^ #81 ^ 1))
  PF :=
    ~low:1[let $1 = RBX >> 4 ^ RBX in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RBX]
  ZF := 0 = RBX
}
400551: cmpq %rbp, %rbx
{
  #84 := RBX - RBP
  CF := RBX < RBP
  OF := high:1[(RBX ^ RBP) & (RBX ^ #84)]
  AF := 0x10 = (0x10 & (#84 ^ RBX ^ RBP))
  PF :=
    ~low:1[let $1 = #84 >> 4 ^ #84 in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[#84]
  ZF := 0 = #84
}
400554: jne -0x16
{
  if (~ZF) {
    jmp 0x400540
  }
}
400556:
400556: addq $0x8, %rsp
{
  #75 := RSP
  RSP := RSP + 8
  CF := RSP < #75
  OF := ~high:1[#75] & (high:1[#75] | high:1[RSP]) &
    ~(high:1[#75] & high:1[RSP])
  AF := 0x10 = (0x10 & (RSP ^ #75 ^ 8))
  PF :=
    ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSP]
  ZF := 0 = RSP
}
40055a: popq %rbx
{
  RBX := mem[RSP, el]:u64
  RSP := RSP + 8
}
40055b: popq %rbp
{
  RBP := mem[RSP, el]:u64
  RSP := RSP + 8
}
40055c: popq %r12
{
  R12 := mem[RSP, el]:u64
  RSP := RSP + 8
}
40055e: popq %r13
{
  R13 := mem[RSP, el]:u64
  RSP := RSP + 8
}
400560: popq %r14
{
  R14 := mem[RSP, el]:u64
  RSP := RSP + 8
}
400562: popq %r15
{
  R15 := mem[RSP, el]:u64
  RSP := RSP + 8
}
400564: retq
{
  #78 := mem[RSP, el]:u64
  RSP := RSP + 8
  jmp #78
}

400570: <__libc_csu_fini>
400570:
400570: rep  retq
{
  #79 := mem[RSP, el]:u64
  RSP := RSP + 8
  jmp #79
}

Disassembly of section .init

400390: <_init>
400390:
400390: subq $0x8, %rsp
{
  #10 := RSP
  RSP := RSP - 8
  CF := #10 < 8
  OF := high:1[(#10 ^ 8) & (#10 ^ RSP)]
  AF := 0x10 = (0x10 & (RSP ^ #10 ^ 8))
  PF :=
    ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSP]
  ZF := 0 = RSP
}
400394: movq 0x200c5d(%rip), %rax
{
  RAX := mem[0x600FF8, el]:u64
}
40039b: testq %rax, %rax
{
  #13 := RAX
  OF := 0
  CF := 0
  AF := unknown[bits]:u1
  PF :=
    ~low:1[let $1 = #13 >> 4 ^ #13 in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[#13]
  ZF := 0 = #13
}
40039e: je 0x5
{
  if (ZF) {
    jmp 0x4003A5
  }
}
4003a0:
4003a0: callq 0x2b
{
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- 0x4003A5
  jmp 0x4003D0
}
4003a5:
4003a5: addq $0x8, %rsp
{
  #15 := RSP
  RSP := RSP + 8
  CF := RSP < #15
  OF := ~high:1[#15] & (high:1[#15] | high:1[RSP]) &
    ~(high:1[#15] & high:1[RSP])
  AF := 0x10 = (0x10 & (RSP ^ #15 ^ 8))
  PF :=
    ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSP]
  ZF := 0 = RSP
}
4003a9: retq
{
  #18 := mem[RSP, el]:u64
  RSP := RSP + 8
  jmp #18
}

Disassembly of section .plt

4003b0: <__libc_start_main@plt-0x10>
4003b0:
4003b0: pushq 0x200c52(%rip)
{
  #8 := mem[0x601008, el]:u64
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- #8
}
4003b6: jmpq *0x200c54(%rip)
{
  jmp (mem[0x601010, el]:u64)
}

4003c0: <__libc_start_main>
4003c0:
4003c0: jmpq *0x200c52(%rip)
{
  special
  (external:__libc_start_main@external)
}
4003c6:
4003c6: pushq $0x0
{
  RSP := RSP - 8
  mem := mem with [RSP, el]:u64 <- 0
}
4003cb: jmp -0x20
{
  jmp 0x4003B0
}

Disassembly of section .fini

400574: <_fini>
400574:
400574: subq $0x8, %rsp
{
  #1 := RSP
  RSP := RSP - 8
  CF := #1 < 8
  OF := high:1[(#1 ^ 8) & (#1 ^ RSP)]
  AF := 0x10 = (0x10 & (RSP ^ #1 ^ 8))
  PF :=
    ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSP]
  ZF := 0 = RSP
}
400578: addq $0x8, %rsp
{
  #4 := RSP
  RSP := RSP + 8
  CF := RSP < #4
  OF := ~high:1[#4] & (high:1[#4] | high:1[RSP]) &
    ~(high:1[#4] & high:1[RSP])
  AF := 0x10 = (0x10 & (RSP ^ #4 ^ 8))
  PF :=
    ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
  SF := high:1[RSP]
  ZF := 0 = RSP
}
40057c: retq
{
  #7 := mem[RSP, el]:u64
  RSP := RSP + 8
  jmp #7
}
