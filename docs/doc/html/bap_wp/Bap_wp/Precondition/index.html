<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Precondition (bap_wp.Bap_wp.Precondition)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">bap_wp</a> &#x00BB; <a href="../index.html">Bap_wp</a> &#x00BB; Precondition</nav><h1>Module <code>Bap_wp.Precondition</code></h1></header><aside><p>This module exports types and utilities to create preconditions for BIR expressions, blocks and subroutines.</p><p>Usage typically involves creating a new (abstract) <a href="../Environment/index.html#type-t"><code>Environment.t</code></a> value, a Z3 context and a <a href="../Environment/index.html#type-var_gen"><code>Environment.var_gen</code></a> using the utility functions, along with the desired post-condition and calling the relevant <code>visit_foo</code> function.</p><p>The resulting precondition can then be tested for satisfiability or provability using the Z3 Solver module.</p></aside><div class="spec module" id="module-Bool"><a href="#module-Bool" class="anchor"></a><code><span class="keyword">module</span> Bool = Z3.Boolean</code></div><div class="spec module" id="module-Env"><a href="#module-Env" class="anchor"></a><code><span class="keyword">module</span> Env = <a href="../index.html#module-Environment">Environment</a></code></div><div class="spec module" id="module-Constr"><a href="#module-Constr" class="anchor"></a><code><span class="keyword">module</span> Constr = <a href="../index.html#module-Constraint">Constraint</a></code></div><dl><dt class="spec type" id="type-hooks"><a href="#type-hooks" class="anchor"></a><code><span class="keyword">type</span> hooks</code><code> = </code><code>{</code><table class="record"><tr id="type-hooks.assume_before" class="anchored"><td class="def field"><a href="#type-hooks.assume_before" class="anchor"></a><code>assume_before : <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span>;</code></td></tr><tr id="type-hooks.assume_after" class="anchored"><td class="def field"><a href="#type-hooks.assume_after" class="anchor"></a><code>assume_after : <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span>;</code></td></tr><tr id="type-hooks.verify_before" class="anchored"><td class="def field"><a href="#type-hooks.verify_before" class="anchor"></a><code>verify_before : <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span>;</code></td></tr><tr id="type-hooks.verify_after" class="anchored"><td class="def field"><a href="#type-hooks.verify_after" class="anchor"></a><code>verify_after : <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span>;</code></td></tr></table><code>}</code></dt><dd><p>Constraints that can be added to the precondition as either assumptions or verification conditions, and when to apply those constraints during a visit to an instruction.</p></dd></dl><dl><dt class="spec value" id="val-z3_expr_zero"><a href="#val-z3_expr_zero" class="anchor"></a><code><span class="keyword">val</span> z3_expr_zero : Z3.context <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></code></dt><dd><p>Create the Z3 BitVector zero value of width <code>i</code>.</p></dd></dl><dl><dt class="spec value" id="val-z3_expr_one"><a href="#val-z3_expr_one" class="anchor"></a><code><span class="keyword">val</span> z3_expr_one : Z3.context <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></code></dt><dd><p>Create the Z3 BitVector 1 value of width <code>i</code>.</p></dd></dl><dl><dt class="spec value" id="val-binop"><a href="#val-binop" class="anchor"></a><code><span class="keyword">val</span> binop : Z3.context <span>&#45;&gt;</span> Bap.Std.binop <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></code></dt><dd><p>Translate a BIR binary operator to a Z3 one.</p></dd></dl><dl><dt class="spec value" id="val-unop"><a href="#val-unop" class="anchor"></a><code><span class="keyword">val</span> unop : Z3.context <span>&#45;&gt;</span> Bap.Std.unop <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></code></dt><dd><p>Translate a BIR unary operator to a Z3 one.</p></dd></dl><dl><dt class="spec value" id="val-cast"><a href="#val-cast" class="anchor"></a><code><span class="keyword">val</span> cast : Z3.context <span>&#45;&gt;</span> Bap.Std.cast <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></code></dt><dd><p>Translate a BIR cast operation into a Z3 one.</p></dd></dl><dl><dt class="spec value" id="val-visit_call"><a href="#val-visit_call" class="anchor"></a><code><span class="keyword">val</span> visit_call : Bap.Std.Call.t <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> <span>&#45;&gt;</span> <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Compute a precondition for given call given a postcondition.</p></dd></dl><dl><dt class="spec value" id="val-get_vars"><a href="#val-get_vars" class="anchor"></a><code><span class="keyword">val</span> get_vars : <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Var.Set.t</code></dt><dd><p>Get <em>every</em> variable from a subroutine.</p></dd></dl><dl><dt class="spec value" id="val-set_of_reg_names"><a href="#val-set_of_reg_names" class="anchor"></a><code><span class="keyword">val</span> set_of_reg_names : <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> Bap.Std.Sub.t <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> Bap.Std.Var.Set.t</code></dt><dd><p>Parses a list of register names found in a subroutine and returns a set of variables representing those registers.</p></dd></dl><dl><dt class="spec value" id="val-init_vars"><a href="#val-init_vars" class="anchor"></a><code><span class="keyword">val</span> init_vars : Bap.Std.Var.Set.t <span>&#45;&gt;</span> <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span> * <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Generates a list of constraints: <code>var == init_var</code> where init_var refers to the initial state of the variable var. Also updates the environment to contain a mapping of Bap variables to their generated init variables.</p><p>Can be used in the specs using <a href="../Environment/index.html#val-mk_init_var"><code>Env.mk_init_var</code></a> and <a href="../Environment/index.html#val-get_init_var"><code>Env.get_init_var</code></a>. e.g. `BV.mk_ult ctx (Env.get_init_var env var) z3_var` is the constraint stating the value of the variable at its initial state is less than its value at the current state.</p></dd></dl><dl><dt class="spec value" id="val-load_z3_mem"><a href="#val-load_z3_mem" class="anchor"></a><code><span class="keyword">val</span> load_z3_mem : Z3.context <span>&#45;&gt;</span> <span>word_size:int</span> <span>&#45;&gt;</span> <span>mem:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span> <span>&#45;&gt;</span> <span>addr:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span> <span>&#45;&gt;</span> Bap.Std.endian <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></code></dt><dd><p>Create a Z3 expression that denotes a load in memory <code>mem</code> at address <code>addr</code> with a word size of <code>word_size</code> bits and endianness <code>endian</code>.</p></dd></dl><dl><dt class="spec value" id="val-store_z3_mem"><a href="#val-store_z3_mem" class="anchor"></a><code><span class="keyword">val</span> store_z3_mem : Z3.context <span>&#45;&gt;</span> <span>word_size:int</span> <span>&#45;&gt;</span> <span>mem:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span> <span>&#45;&gt;</span> <span>addr:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span> <span>&#45;&gt;</span> <span>content:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span> <span>&#45;&gt;</span> Bap.Std.endian <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></code></dt><dd><p>Create a Z3 expression that denotes a write in memory <code>mem</code> at address <code>addr</code>, writing the value <code>content</code> with a word size of <code>word_size</code> bits and endianness <code>endian</code>.</p></dd></dl><dl><dt class="spec value" id="val-bv_to_bool"><a href="#val-bv_to_bool" class="anchor"></a><code><span class="keyword">val</span> bv_to_bool : <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span>&#45;&gt;</span> Z3.context <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></code></dt><dd><p>Translates the sort of a Z3 expression from BitVector of variable width to a Boolean.</p></dd></dl><dl><dt class="spec value" id="val-word_to_z3"><a href="#val-word_to_z3" class="anchor"></a><code><span class="keyword">val</span> word_to_z3 : Z3.context <span>&#45;&gt;</span> Bap.Std.Word.t <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></code></dt><dd><p>Translate a BAP word to a Z3 BitVector expression of the same width and value.</p></dd></dl><dl><dt class="spec value" id="val-exp_to_z3"><a href="#val-exp_to_z3" class="anchor"></a><code><span class="keyword">val</span> exp_to_z3 : Bap.Std.exp <span>&#45;&gt;</span> <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> * <a href="index.html#type-hooks">hooks</a> * <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Translate a BIR expression to a Z3 expression, by a straightforward translation of the expression semantics, using the context for values of variables.</p><p>Returns also the assumptions and the VCs generated by the hooks in the environment.</p></dd></dl><dl><dt class="spec value" id="val-input_regs"><a href="#val-input_regs" class="anchor"></a><code><span class="keyword">val</span> input_regs : Bap.Std.Arch.t <span>&#45;&gt;</span> <span>Bap.Std.Var.t list</span></code></dt><dd><p>Obtains all possible registers that can be used to hold input values to a function call for a given architecture.</p></dd></dl><dl><dt class="spec value" id="val-caller_saved_regs"><a href="#val-caller_saved_regs" class="anchor"></a><code><span class="keyword">val</span> caller_saved_regs : Bap.Std.Arch.t <span>&#45;&gt;</span> <span>Bap.Std.Var.t list</span></code></dt><dd><p>Obtains the caller saved-registers for a given architecture.</p></dd></dl><dl><dt class="spec value" id="val-callee_saved_regs"><a href="#val-callee_saved_regs" class="anchor"></a><code><span class="keyword">val</span> callee_saved_regs : Bap.Std.Arch.t <span>&#45;&gt;</span> <span>Bap.Std.Var.t list</span></code></dt><dd><p>Obtains the callee-saved registers for a given architecture.</p></dd></dl><dl><dt class="spec value" id="val-spec_verifier_error"><a href="#val-spec_verifier_error" class="anchor"></a><code><span class="keyword">val</span> spec_verifier_error : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is used for the functions <code>__assert_fail</code> or <code>__VERIFIER_error</code>. It returns the precondition <code>false</code>.</p></dd></dl><dl><dt class="spec value" id="val-spec_verifier_assume"><a href="#val-spec_verifier_assume" class="anchor"></a><code><span class="keyword">val</span> spec_verifier_assume : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is used for assumptions made with <code>__VERIFIER_assume(assumption)</code>. It returns a precondition of <code>assumption =&gt; post</code>.</p></dd></dl><dl><dt class="spec value" id="val-spec_verifier_nondet"><a href="#val-spec_verifier_nondet" class="anchor"></a><code><span class="keyword">val</span> spec_verifier_nondet : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is used for functions of <code>__VERIFIER_nondet_type</code>, which returns a nondeterministic value for the type. This spec chaoses the register that holds the output value from the function call.</p></dd></dl><dl><dt class="spec value" id="val-spec_empty"><a href="#val-spec_empty" class="anchor"></a><code><span class="keyword">val</span> spec_empty : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is used for empty subroutines that have no blocks. This spec is a nop, returning the postcondition as the precondition.</p></dd></dl><dl><dt class="spec value" id="val-spec_arg_terms"><a href="#val-spec_arg_terms" class="anchor"></a><code><span class="keyword">val</span> spec_arg_terms : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is used when BAP is able to generate <code>arg term</code>s for the subroutine in the case when an API is specified. It creates a function symbol for each output register given the input registers in the form <code>func_out_reg(in_reg1, in_reg2, ...)</code>.</p></dd></dl><dl><dt class="spec value" id="val-spec_rax_out"><a href="#val-spec_rax_out" class="anchor"></a><code><span class="keyword">val</span> spec_rax_out : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is used when RAX or EAX is used on the left-hand side of the subroutine. It creates a function symbol for RAX/EAX with the input registers as arguments.</p></dd></dl><dl><dt class="spec value" id="val-spec_chaos_rax"><a href="#val-spec_chaos_rax" class="anchor"></a><code><span class="keyword">val</span> spec_chaos_rax : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is similar to <a href="index.html#val-spec_rax_out"><code>spec_rax_out</code></a>, but will create a function symbol for RAX regardless if it was used in the left-hand side of the subroutine or not. This spec only works for x86_64 architectures.</p></dd></dl><dl><dt class="spec value" id="val-spec_chaos_caller_saved"><a href="#val-spec_chaos_caller_saved" class="anchor"></a><code><span class="keyword">val</span> spec_chaos_caller_saved : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is used for x86 architectures and will create a function symbol for all caller-saved registers given with the input registers as arguments.</p></dd></dl><dl><dt class="spec value" id="val-spec_afl_maybe_log"><a href="#val-spec_afl_maybe_log" class="anchor"></a><code><span class="keyword">val</span> spec_afl_maybe_log : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is used for the function <code>__afl_maybe_log</code>. It chaoses the registers RAX, RCX, and RDX. In retrowrite, these registers are stored on the stack, <code>__afl_maybe_log</code> is called, and then the registers are restored.</p></dd></dl><dl><dt class="spec value" id="val-spec_inline"><a href="#val-spec_inline" class="anchor"></a><code><span class="keyword">val</span> spec_inline : <span>Bap.Std.Sub.t Bap.Std.Seq.t</span> <span>&#45;&gt;</span> Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></code></dt><dd><p>This spec is used to inline a function call. It calls <a href="index.html#val-visit_sub"><code>visit_sub</code></a> on the target function being called.</p></dd></dl><dl><dt class="spec value" id="val-spec_default"><a href="#val-spec_default" class="anchor"></a><code><span class="keyword">val</span> spec_default : Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a></code></dt><dd><p>The default spec used when mapping subroutines to their preconditions. This spec sets the constraint representing the subroutine being called to true, and in x86 architectures, increments the value of the stack pointer on return by the address size.</p></dd></dl><dl><dt class="spec value" id="val-jmp_spec_default"><a href="#val-jmp_spec_default" class="anchor"></a><code><span class="keyword">val</span> jmp_spec_default : <a href="../Environment/index.html#type-jmp_spec">Env.jmp_spec</a></code></dt><dd><p>The default jmp spec for handling branches in a BIR program.</p></dd></dl><dl><dt class="spec value" id="val-indirect_spec_default"><a href="#val-indirect_spec_default" class="anchor"></a><code><span class="keyword">val</span> indirect_spec_default : <a href="../Environment/index.html#type-indirect_spec">Env.indirect_spec</a></code></dt><dd><p>The default indirect call spec.</p></dd></dl><dl><dt class="spec value" id="val-jmp_spec_reach"><a href="#val-jmp_spec_reach" class="anchor"></a><code><span class="keyword">val</span> jmp_spec_reach : <a href="../Constraint/index.html#type-path">Constr.path</a> <span>&#45;&gt;</span> <a href="../Environment/index.html#type-jmp_spec">Env.jmp_spec</a></code></dt><dd><p>A jump spec that generates constraints for reaching a program point, according to a map specifying whether a jump was taken or not.</p></dd></dl><dl><dt class="spec value" id="val-int_spec_default"><a href="#val-int_spec_default" class="anchor"></a><code><span class="keyword">val</span> int_spec_default : <a href="../Environment/index.html#type-int_spec">Env.int_spec</a></code></dt><dd><p>The default interrupt spec for handling interrupts in a BIR program.</p></dd></dl><dl><dt class="spec value" id="val-non_null_load_vc"><a href="#val-non_null_load_vc" class="anchor"></a><code><span class="keyword">val</span> non_null_load_vc : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></code></dt><dd><p>This spec enforces each memory read to be on a non-null address.</p></dd></dl><dl><dt class="spec value" id="val-non_null_load_assert"><a href="#val-non_null_load_assert" class="anchor"></a><code><span class="keyword">val</span> non_null_load_assert : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></code></dt><dd><p>This spec <em>assumes</em> each memory read to be on a non-null address.</p></dd></dl><dl><dt class="spec value" id="val-non_null_store_vc"><a href="#val-non_null_store_vc" class="anchor"></a><code><span class="keyword">val</span> non_null_store_vc : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></code></dt><dd><p>This spec enforces each memory write to be on a non-null address.</p></dd></dl><dl><dt class="spec value" id="val-non_null_store_assert"><a href="#val-non_null_store_assert" class="anchor"></a><code><span class="keyword">val</span> non_null_store_assert : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></code></dt><dd><p>This spec <em>assumes</em> each memory write to be on a non-null address.</p></dd></dl><dl><dt class="spec value" id="val-mem_read_offsets"><a href="#val-mem_read_offsets" class="anchor"></a><code><span class="keyword">val</span> mem_read_offsets : <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <span>(<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a>)</span> <span>&#45;&gt;</span> <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></code></dt><dd><p>This spec <em>assumes</em> that the value of a memory read at address <code>a</code> in the original binary is equal to the memory read of the modified binary at address <code>a + d</code>.</p></dd></dl><dl><dt class="spec value" id="val-num_unroll"><a href="#val-num_unroll" class="anchor"></a><code><span class="keyword">val</span> num_unroll : <span>int Stdlib.ref</span></code></dt><dd><p>Constant which determines the number of loop unrollings.</p><p>We use the default value <code>!num_unroll = 5</code>.</p></dd></dl><dl><dt class="spec value" id="val-default_stack_range"><a href="#val-default_stack_range" class="anchor"></a><code><span class="keyword">val</span> default_stack_range : <a href="../Environment/index.html#type-mem_range">Env.mem_range</a></code></dt><dd><p>The default stack range has a base address at 0x40000000 and size of 0x800000. The stack grows downward.</p></dd></dl><dl><dt class="spec value" id="val-default_data_section_range"><a href="#val-default_data_section_range" class="anchor"></a><code><span class="keyword">val</span> default_data_section_range : <a href="../Environment/index.html#type-mem_range">Env.mem_range</a></code></dt><dt class="spec value" id="val-mk_env"><a href="#val-mk_env" class="anchor"></a><code><span class="keyword">val</span> mk_env : <span>?&#8288;subs:<span>Bap.Std.Sub.t Bap.Std.Seq.t</span></span> <span>&#45;&gt;</span> <span>?&#8288;specs:<span><span>(Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span>)</span> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;default_spec:<span>(Bap.Std.Sub.t <span>&#45;&gt;</span> Bap.Std.Arch.t <span>&#45;&gt;</span> <a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;indirect_spec:<a href="../Environment/index.html#type-indirect_spec">Env.indirect_spec</a></span> <span>&#45;&gt;</span> <span>?&#8288;jmp_spec:<a href="../Environment/index.html#type-jmp_spec">Env.jmp_spec</a></span> <span>&#45;&gt;</span> <span>?&#8288;int_spec:<a href="../Environment/index.html#type-int_spec">Env.int_spec</a></span> <span>&#45;&gt;</span> <span>?&#8288;exp_conds:<span><a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;num_loop_unroll:int</span> <span>&#45;&gt;</span> <span>?&#8288;arch:Bap.Std.Arch.t</span> <span>&#45;&gt;</span> <span>?&#8288;freshen_vars:bool</span> <span>&#45;&gt;</span> <span>?&#8288;use_fun_input_regs:bool</span> <span>&#45;&gt;</span> <span>?&#8288;stack_range:<a href="../Environment/index.html#type-mem_range">Env.mem_range</a></span> <span>&#45;&gt;</span> <span>?&#8288;data_section_range:<a href="../Environment/index.html#type-mem_range">Env.mem_range</a></span> <span>&#45;&gt;</span> Z3.context <span>&#45;&gt;</span> <a href="../Environment/index.html#type-var_gen">Env.var_gen</a> <span>&#45;&gt;</span> <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Creates an environment with</p><ul><li>an empty sequence of subroutines to initialize function specs</li><li>an empty list of <a href="../Environment/index.html#type-fun_spec"><code>Environment.fun_spec</code></a>s that summarize the precondition for a function call</li><li>the default <a href="../Environment/index.html#type-jmp_spec"><code>Environment.jmp_spec</code></a> that summarizes the precondition at a jump</li><li>the default <a href="../Environment/index.html#type-int_spec"><code>Environment.int_spec</code></a> that summarizes the precondition for an interrupt</li><li>an empty list of <a href="../Environment/index.html#type-exp_cond"><code>Environment.exp_cond</code></a>s which adds assumptions and VCs to the precondition as hooks on certain instructions</li><li>a loop unroll count of 5 for use when reaching a back edge during analysis</li><li>an architecture of x86_64 for architecture specific constraints and specs</li><li>freshening variables set to false. Should be set to true in order to represent the variables in the modified binary</li><li>the option to use all function input registers when generating function symbols at a call site set to true</li><li>the default concrete range of addresses of the stack for constraints about the stack with a base of 0x40000000 and size of 8Mbs</li><li>the default concreate range of addresses of the data section for constraints about the data section with a base of 0x000000 and size of 8Mbs</li></ul><p>unless specified. A Z3 context and var_gen are required to generate Z3 expressions and create fresh variables.</p></dd></dl><dl><dt class="spec value" id="val-visit_jmp"><a href="#val-visit_jmp" class="anchor"></a><code><span class="keyword">val</span> visit_jmp : <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> <span>&#45;&gt;</span> Bap.Std.Jmp.t <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Create a precondition for a given jump expression, depending on the postcondition and (potentially) the preconditions for the jump targets or the loop invariants.</p><p>We do not handle indirect jumps at all: we just return the current postcondition, which is unsound of course.</p></dd></dl><dl><dt class="spec value" id="val-visit_elt"><a href="#val-visit_elt" class="anchor"></a><code><span class="keyword">val</span> visit_elt : <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> <span>&#45;&gt;</span> Bap.Std.Blk.elt <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Create a precondition for a given block element, which may be a jump, an assignment or a phi node. Depends on the postcondition, and the preconditions of other blocks or subroutines if the elt is a jump.</p><p>Note that we are not complete for phi nodes, and the Z3 semantics may be weaker than the BIR semantics.</p></dd></dl><dl><dt class="spec value" id="val-visit_block"><a href="#val-visit_block" class="anchor"></a><code><span class="keyword">val</span> visit_block : <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> <span>&#45;&gt;</span> Bap.Std.Blk.t <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Create a precondition for a given block. Depends on the postcondition, and the preconditions of other blocks or subroutines if there is a jump.</p><p>Currently we do not handle loops very well, except by suppressing all back- edges in the CFG.</p></dd></dl><dl><dt class="spec value" id="val-visit_sub"><a href="#val-visit_sub" class="anchor"></a><code><span class="keyword">val</span> visit_sub : <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> <span>&#45;&gt;</span> Bap.Std.Sub.t <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Create a precondition for a given subroutine. Depends on the postcondition, and the preconditions of other blocks or subroutines if there is a jump.</p><p>Currently we do not handle loops very well, except by suppressing all back- edges in the CFG.</p></dd></dl><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <span>?&#8288;refute:bool</span> <span>&#45;&gt;</span> <span>?&#8288;print_constr:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;debug:bool</span> <span>&#45;&gt;</span> Z3.Solver.solver <span>&#45;&gt;</span> Z3.context <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> <span>&#45;&gt;</span> Z3.Solver.status</code></dt><dd><p>Calls Z3 to check for a countermodel for the precondition of a BIR program. If refute is set to false, it checks for a model instead. If ~print_constr is called and contains &quot;smtlib&quot;, then Z3's solver (smt lib 2) will be printed. If ~debug is called and set to true, it will be passed to print statistics for Constr.eval inside this function</p></dd></dl><dl><dt class="spec value" id="val-exclude"><a href="#val-exclude" class="anchor"></a><code><span class="keyword">val</span> exclude : Z3.Solver.solver <span>&#45;&gt;</span> Z3.context <span>&#45;&gt;</span> <span>var:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span> <span>&#45;&gt;</span> <span>pre:<a href="../Constraint/index.html#type-t">Constr.t</a></span> <span>&#45;&gt;</span> Z3.Solver.status</code></dt><dd><p>Adds a constraint to the Z3 solver in which var does not equal its value from the original Z3 model, then runs the Z3 solver again.</p><p>This has a side effect that updates the state of the solver. The solver's state can be reverted back with <code>Z3.Solver.pop</code>.</p></dd></dl><dl><dt class="spec value" id="val-set_sp_range"><a href="#val-set_sp_range" class="anchor"></a><code><span class="keyword">val</span> set_sp_range : <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a></code></dt><dd><p>Hypothesis that the stack pointer is within the valid range of the stack according to the environment.</p></dd></dl></div></body></html>