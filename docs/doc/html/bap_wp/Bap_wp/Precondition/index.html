<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Precondition (bap_wp.Bap_wp.Precondition)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">bap_wp</a> &#x00BB; <a href="../index.html">Bap_wp</a> &#x00BB; Precondition</nav><header class="odoc-preamble"><h1>Module <code><span>Bap_wp.Precondition</span></code></h1><p>This module exports types and utilities to create preconditions for BIR expressions, blocks and subroutines.</p><p>Usage typically involves creating a new (abstract) <a href="../Environment/index.html#type-t"><code>Environment.t</code></a> value, a Z3 context and a <a href="../Environment/index.html#type-var_gen"><code>Environment.var_gen</code></a> using the utility functions, along with the desired post-condition and calling the relevant <code>visit_foo</code> function.</p><p>The resulting precondition can then be tested for satisfiability or provability using the Z3 Solver module.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-Bool" class="anchored"><a href="#module-Bool" class="anchor"></a><code><span><span class="keyword">module</span> Bool</span><span> = <span class="xref-unresolved">Z3</span>.Boolean</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Env" class="anchored"><a href="#module-Env" class="anchor"></a><code><span><span class="keyword">module</span> Env</span><span> = <a href="../Environment/index.html">Environment</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Constr" class="anchored"><a href="#module-Constr" class="anchor"></a><code><span><span class="keyword">module</span> Constr</span><span> = <a href="../Constraint/index.html">Constraint</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-hooks" class="anchored"><a href="#type-hooks" class="anchor"></a><code><span><span class="keyword">type</span> hooks</span><span> = </span><span>{</span></code><table><tr id="type-hooks.assume_before" class="anchored"><td class="def record field"><a href="#type-hooks.assume_before" class="anchor"></a><code><span>assume_before : <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span>;</span></code></td></tr><tr id="type-hooks.assume_after" class="anchored"><td class="def record field"><a href="#type-hooks.assume_after" class="anchor"></a><code><span>assume_after : <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span>;</span></code></td></tr><tr id="type-hooks.verify_before" class="anchored"><td class="def record field"><a href="#type-hooks.verify_before" class="anchor"></a><code><span>verify_before : <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span>;</span></code></td></tr><tr id="type-hooks.verify_after" class="anchored"><td class="def record field"><a href="#type-hooks.verify_after" class="anchor"></a><code><span>verify_after : <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Constraints that can be added to the precondition as either assumptions or verification conditions, and when to apply those constraints during a visit to an instruction.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-z3_expr_zero" class="anchored"><a href="#val-z3_expr_zero" class="anchor"></a><code><span><span class="keyword">val</span> z3_expr_zero : <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Create the Z3 BitVector zero value of width <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-z3_expr_one" class="anchored"><a href="#val-z3_expr_one" class="anchor"></a><code><span><span class="keyword">val</span> z3_expr_one : <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Create the Z3 BitVector 1 value of width <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-binop" class="anchored"><a href="#val-binop" class="anchor"></a><code><span><span class="keyword">val</span> binop : 
  <span>?smtlib_compat:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.binop <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Translate a BIR binary operator to a Z3 one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unop" class="anchored"><a href="#val-unop" class="anchor"></a><code><span><span class="keyword">val</span> unop : <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.unop <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Translate a BIR unary operator to a Z3 one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cast" class="anchored"><a href="#val-cast" class="anchor"></a><code><span><span class="keyword">val</span> cast : 
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.cast <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Translate a BIR cast operation into a Z3 one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visit_call" class="anchored"><a href="#val-visit_call" class="anchor"></a><code><span><span class="keyword">val</span> visit_call : 
  <span><span class="xref-unresolved">Bap</span>.Std.Call.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Jmp.t <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Compute a precondition for given call given a postcondition.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-vars_from_sub" class="anchored"><a href="#val-vars_from_sub" class="anchor"></a><code><span><span class="keyword">val</span> vars_from_sub : <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Bap</span>.Std.Var.Set.t</span></code></div><div class="spec-doc"><p>Get <em>every</em> variable from a subroutine.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_vars" class="anchored"><a href="#val-get_vars" class="anchor"></a><code><span><span class="keyword">val</span> get_vars : <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Bap</span>.Std.Var.Set.t</span></code></div><div class="spec-doc"><p>Get <em>every</em> variable from a subroutine and all general purpose registers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_of_reg_names" class="anchored"><a href="#val-set_of_reg_names" class="anchor"></a><code><span><span class="keyword">val</span> set_of_reg_names : 
  <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Bap</span>.Std.Var.Set.t</span></code></div><div class="spec-doc"><p>Parses a list of register names found in a subroutine and returns a set of variables representing those registers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init_vars" class="anchored"><a href="#val-init_vars" class="anchor"></a><code><span><span class="keyword">val</span> init_vars : <span><span class="xref-unresolved">Bap</span>.Std.Var.Set.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Generates a list of constraints: <code>var == init_var</code> where init_var refers to the initial state of the variable var. Also updates the environment to contain a mapping of Bap variables to their generated init variables.</p><p>Can be used in the specs using <a href="../Environment/index.html#val-mk_init_var"><code>Env.mk_init_var</code></a> and <a href="../Environment/index.html#val-get_init_var"><code>Env.get_init_var</code></a>. e.g. `BV.mk_ult ctx (Env.get_init_var env var) z3_var` is the constraint stating the value of the variable at its initial state is less than its value at the current state.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init_mem_range" class="anchored"><a href="#val-init_mem_range" class="anchor"></a><code><span><span class="keyword">val</span> init_mem_range : 
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span>bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Bap</span>.Std.value <span class="xref-unresolved">Bap</span>.Std.memmap</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Bap</span>.Std.value <span class="xref-unresolved">Bap</span>.Std.memmap</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Returns a Z3 expression that returns true if an address occurs in the range of memory addresses initialized by the init-mem flag in either the original or modified binaries.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init_mem" class="anchored"><a href="#val-init_mem" class="anchor"></a><code><span><span class="keyword">val</span> init_mem : 
  <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Bap</span>.Std.value <span class="xref-unresolved">Bap</span>.Std.memmap</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Utils/Code_addrs/index.html#type-t">Utils.Code_addrs.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-t">Constr.t</a> list</span> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Generates a list of constraints: <code>mem[0xloc] == 0xval</code> where the <code>mem</code> variable is taken from the environment, and the loc/val pairs are taken from the memmap.</p><p>An optional set of known code addresses is provided. The addresses in this set are ignored when generating the constraints.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-load_z3_mem" class="anchored"><a href="#val-load_z3_mem" class="anchor"></a><code><span><span class="keyword">val</span> load_z3_mem : 
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span>word_size:int <span class="arrow">&#45;&gt;</span></span>
  <span>mem:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span>addr:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.endian <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Create a Z3 expression that denotes a load in memory <code>mem</code> at address <code>addr</code> with a word size of <code>word_size</code> bits and endianness <code>endian</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-store_z3_mem" class="anchored"><a href="#val-store_z3_mem" class="anchor"></a><code><span><span class="keyword">val</span> store_z3_mem : 
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span>word_size:int <span class="arrow">&#45;&gt;</span></span>
  <span>mem:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span>addr:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span>content:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.endian <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Create a Z3 expression that denotes a write in memory <code>mem</code> at address <code>addr</code>, writing the value <code>content</code> with a word size of <code>word_size</code> bits and endianness <code>endian</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bv_to_bool" class="anchored"><a href="#val-bv_to_bool" class="anchor"></a><code><span><span class="keyword">val</span> bv_to_bool : <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Translates the sort of a Z3 expression from BitVector of variable width to a Boolean.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-word_to_z3" class="anchored"><a href="#val-word_to_z3" class="anchor"></a><code><span><span class="keyword">val</span> word_to_z3 : <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Word.t <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Translate a BAP word to a Z3 BitVector expression of the same width and value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exp_to_z3" class="anchored"><a href="#val-exp_to_z3" class="anchor"></a><code><span><span class="keyword">val</span> exp_to_z3 : <span><span class="xref-unresolved">Bap</span>.Std.exp <span class="arrow">&#45;&gt;</span></span> <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> * <a href="#type-hooks">hooks</a> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Translate a BIR expression to a Z3 expression, by a straightforward translation of the expression semantics, using the context for values of variables.</p><p>Returns also the assumptions and the VCs generated by the hooks in the environment.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-input_regs" class="anchored"><a href="#val-input_regs" class="anchor"></a><code><span><span class="keyword">val</span> input_regs : <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Var.t list</span></span></code></div><div class="spec-doc"><p>Obtains all possible registers that can be used to hold input values to a function call for a given target.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-caller_saved_regs" class="anchored"><a href="#val-caller_saved_regs" class="anchor"></a><code><span><span class="keyword">val</span> caller_saved_regs : <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Var.t list</span></span></code></div><div class="spec-doc"><p>Obtains the caller saved-registers for a given target.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-callee_saved_regs" class="anchored"><a href="#val-callee_saved_regs" class="anchor"></a><code><span><span class="keyword">val</span> callee_saved_regs : <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Var.t list</span></span></code></div><div class="spec-doc"><p>Obtains the callee-saved registers for a given target.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-user_func_spec" class="anchored"><a href="#val-user_func_spec" class="anchor"></a><code><span><span class="keyword">val</span> user_func_spec : 
  <span>sub_name:string <span class="arrow">&#45;&gt;</span></span>
  <span>sub_pre:string <span class="arrow">&#45;&gt;</span></span>
  <span>sub_post:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used to handle user-specified subroutine specs via the --user-func-specs flag, using the user-specified subroutine name, pre and post-conditions. *</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_verifier_error" class="anchored"><a href="#val-spec_verifier_error" class="anchor"></a><code><span><span class="keyword">val</span> spec_verifier_error : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used for the functions <code>__assert_fail</code> or <code>__VERIFIER_error</code>. It returns the precondition <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_verifier_assume" class="anchored"><a href="#val-spec_verifier_assume" class="anchor"></a><code><span><span class="keyword">val</span> spec_verifier_assume : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used for assumptions made with <code>__VERIFIER_assume(assumption)</code>. It returns a precondition of <code>assumption =&gt; post</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_verifier_nondet" class="anchored"><a href="#val-spec_verifier_nondet" class="anchor"></a><code><span><span class="keyword">val</span> spec_verifier_nondet : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used for functions of <code>__VERIFIER_nondet_type</code>, which returns a nondeterministic value for the type. This spec chaoses the register that holds the output value from the function call.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_empty" class="anchored"><a href="#val-spec_empty" class="anchor"></a><code><span><span class="keyword">val</span> spec_empty : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used for empty subroutines that have no blocks. This spec is a nop, returning the postcondition as the precondition.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_arg_terms" class="anchored"><a href="#val-spec_arg_terms" class="anchor"></a><code><span><span class="keyword">val</span> spec_arg_terms : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used when BAP is able to generate <code>arg term</code>s for the subroutine in the case when an API is specified. It creates a function symbol for each output register given the input registers in the form <code>func_out_reg(in_reg1, in_reg2, ...)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_rax_out" class="anchored"><a href="#val-spec_rax_out" class="anchor"></a><code><span><span class="keyword">val</span> spec_rax_out : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used when RAX or EAX is used on the left-hand side of the subroutine. It creates a function symbol for RAX/EAX with the input registers as arguments.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_chaos_rax" class="anchored"><a href="#val-spec_chaos_rax" class="anchor"></a><code><span><span class="keyword">val</span> spec_chaos_rax : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is similar to <a href="#val-spec_rax_out"><code>spec_rax_out</code></a>, but will create a function symbol for RAX regardless if it was used in the left-hand side of the subroutine or not. This spec only works for x86_64 architectures.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_chaos_caller_saved" class="anchored"><a href="#val-spec_chaos_caller_saved" class="anchor"></a><code><span><span class="keyword">val</span> spec_chaos_caller_saved : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used for x86 architectures and will create a function symbol for all caller-saved registers given with the input registers as arguments.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_afl_maybe_log" class="anchored"><a href="#val-spec_afl_maybe_log" class="anchor"></a><code><span><span class="keyword">val</span> spec_afl_maybe_log : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used for the function <code>__afl_maybe_log</code>. It chaoses the registers RAX, RCX, and RDX. In retrowrite, these registers are stored on the stack, <code>__afl_maybe_log</code> is called, and then the registers are restored.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_inline" class="anchored"><a href="#val-spec_inline" class="anchor"></a><code><span><span class="keyword">val</span> spec_inline : 
  <span><span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="xref-unresolved">Bap</span>.Std.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span></span></code></div><div class="spec-doc"><p>This spec is used to inline a function call. It calls <a href="#val-visit_sub"><code>visit_sub</code></a> on the target function being called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spec_default" class="anchored"><a href="#val-spec_default" class="anchor"></a><code><span><span class="keyword">val</span> spec_default : 
  <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a></span></code></div><div class="spec-doc"><p>The default spec used when mapping subroutines to their preconditions. This spec sets the constraint representing the subroutine being called to true, and in x86 architectures, increments the value of the stack pointer on return by the address size.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-jmp_spec_default" class="anchored"><a href="#val-jmp_spec_default" class="anchor"></a><code><span><span class="keyword">val</span> jmp_spec_default : <a href="../Environment/index.html#type-jmp_spec">Env.jmp_spec</a></span></code></div><div class="spec-doc"><p>The default jmp spec for handling branches in a BIR program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-indirect_spec_default" class="anchored"><a href="#val-indirect_spec_default" class="anchor"></a><code><span><span class="keyword">val</span> indirect_spec_default : <a href="../Environment/index.html#type-indirect_spec">Env.indirect_spec</a></span></code></div><div class="spec-doc"><p>The default indirect call spec.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-jmp_spec_reach" class="anchored"><a href="#val-jmp_spec_reach" class="anchor"></a><code><span><span class="keyword">val</span> jmp_spec_reach : <span><a href="../Constraint/index.html#type-path">Constr.path</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Environment/index.html#type-jmp_spec">Env.jmp_spec</a></span></code></div><div class="spec-doc"><p>A jump spec that generates constraints for reaching a program point, according to a map specifying whether a jump was taken or not.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int_spec_default" class="anchored"><a href="#val-int_spec_default" class="anchor"></a><code><span><span class="keyword">val</span> int_spec_default : <a href="../Environment/index.html#type-int_spec">Env.int_spec</a></span></code></div><div class="spec-doc"><p>The default interrupt spec for handling interrupts in a BIR program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-non_null_load_vc" class="anchored"><a href="#val-non_null_load_vc" class="anchor"></a><code><span><span class="keyword">val</span> non_null_load_vc : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></span></code></div><div class="spec-doc"><p>This spec enforces each memory read to be on a non-null address.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-non_null_load_assert" class="anchored"><a href="#val-non_null_load_assert" class="anchor"></a><code><span><span class="keyword">val</span> non_null_load_assert : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></span></code></div><div class="spec-doc"><p>This spec <em>assumes</em> each memory read to be on a non-null address.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-non_null_store_vc" class="anchored"><a href="#val-non_null_store_vc" class="anchor"></a><code><span><span class="keyword">val</span> non_null_store_vc : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></span></code></div><div class="spec-doc"><p>This spec enforces each memory write to be on a non-null address.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-non_null_store_assert" class="anchored"><a href="#val-non_null_store_assert" class="anchor"></a><code><span><span class="keyword">val</span> non_null_store_assert : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></span></code></div><div class="spec-doc"><p>This spec <em>assumes</em> each memory write to be on a non-null address.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valid_load_vc" class="anchored"><a href="#val-valid_load_vc" class="anchor"></a><code><span><span class="keyword">val</span> valid_load_vc : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></span></code></div><div class="spec-doc"><p>This spec enforces each memory read to be in a valid region of memory, i.e. either on the stack or heap.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valid_load_assert" class="anchored"><a href="#val-valid_load_assert" class="anchor"></a><code><span><span class="keyword">val</span> valid_load_assert : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></span></code></div><div class="spec-doc"><p>This spec <em>assumes</em> each memory read to be in a valid region of memory, i.e. either on the stack or heap.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valid_store_vc" class="anchored"><a href="#val-valid_store_vc" class="anchor"></a><code><span><span class="keyword">val</span> valid_store_vc : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></span></code></div><div class="spec-doc"><p>This spec enforces each memory write to be in a valid region of memory, i.e. either on the stack or heap.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valid_store_assert" class="anchored"><a href="#val-valid_store_assert" class="anchor"></a><code><span><span class="keyword">val</span> valid_store_assert : <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></span></code></div><div class="spec-doc"><p>This spec <em>assumes</em> each memory write to be in a valid region of memory, i.e. either on the stack or heap.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_read_offsets" class="anchored"><a href="#val-mem_read_offsets" class="anchor"></a><code><span><span class="keyword">val</span> mem_read_offsets : 
  <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>init_mem:<span>( <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>offsets:<span>( <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> )</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a></span></code></div><div class="spec-doc"><p>This spec <em>assumes</em> that the value of a memory read at address <code>a</code> in the original binary is equal to the memory read of the modified binary at address <code>a + d</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-num_unroll" class="anchored"><a href="#val-num_unroll" class="anchor"></a><code><span><span class="keyword">val</span> num_unroll : <span>int <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Constant which determines the number of loop unrollings.</p><p>We use the default value <code>!num_unroll = 5</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-default_stack_range" class="anchored"><a href="#val-default_stack_range" class="anchor"></a><code><span><span class="keyword">val</span> default_stack_range : <a href="../Environment/index.html#type-mem_range">Env.mem_range</a></span></code></div><div class="spec-doc"><p>The default stack range has a base address at 0x40000000 and size of 0x800000. The stack grows downward.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-default_data_section_range" class="anchored"><a href="#val-default_data_section_range" class="anchor"></a><code><span><span class="keyword">val</span> default_data_section_range : <a href="../Environment/index.html#type-mem_range">Env.mem_range</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_env" class="anchored"><a href="#val-mk_env" class="anchor"></a><code><span><span class="keyword">val</span> mk_env : 
  <span>?subs:<span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="xref-unresolved">Bap</span>.Std.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?specs:
    <span><span>( <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span>
      <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
      <span><a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> option</span> )</span>
      list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?default_spec:
    <span>( <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span> <a href="../Environment/index.html#type-fun_spec">Env.fun_spec</a> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?indirect_spec:<a href="../Environment/index.html#type-indirect_spec">Env.indirect_spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?jmp_spec:<a href="../Environment/index.html#type-jmp_spec">Env.jmp_spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?int_spec:<a href="../Environment/index.html#type-int_spec">Env.int_spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?exp_conds:<span><a href="../Environment/index.html#type-exp_cond">Env.exp_cond</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?loop_handlers:<span><span>( <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../Environment/index.html#type-loop_handler">Env.loop_handler</a> option</span> )</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?default_loop_handler:<a href="../Environment/index.html#type-loop_handler">Env.loop_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?freshen_vars:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?use_fun_input_regs:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?stack_range:<a href="../Environment/index.html#type-mem_range">Env.mem_range</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?data_section_range:<a href="../Environment/index.html#type-mem_range">Env.mem_range</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?func_name_map:<span>string <span class="xref-unresolved">Core</span>.String.Map.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?smtlib_compat:bool <span class="arrow">&#45;&gt;</span></span>
  <span>target:<span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-var_gen">Env.var_gen</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Creates an environment with</p><ul><li>an empty sequence of subroutines to initialize function specs</li><li>an empty list of <a href="../Environment/index.html#type-fun_spec"><code>Environment.fun_spec</code></a>s that summarize the precondition for a function call</li><li>the default <a href="../Environment/index.html#type-jmp_spec"><code>Environment.jmp_spec</code></a> that summarizes the precondition at a jump</li><li>the default <a href="../Environment/index.html#type-int_spec"><code>Environment.int_spec</code></a> that summarizes the precondition for an interrupt</li><li>an empty list of <a href="../Environment/index.html#type-exp_cond"><code>Environment.exp_cond</code></a>s which adds assumptions and VCs to the precondition as hooks on certain instructions</li><li>a loop unroll count of 5 for use when reaching a back edge during analysis</li><li>a loop handler that can unroll a loop or check a loop invariant</li><li>a target architecture for specific constraints and specs</li><li>freshening variables set to false. Should be set to true in order to represent the variables in the modified binary</li><li>the option to use all function input registers when generating function symbols at a call site set to true</li><li>the default concrete range of addresses of the stack for constraints about the stack with a base of 0x40000000 and size of 8Mbs</li><li>the default concreate range of addresses of the data section for constraints about the data section with a base of 0x000000 and size of 8Mbs</li></ul><p>unless specified. A Z3 context and var_gen are required to generate Z3 expressions and create fresh variables.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visit_jmp" class="anchored"><a href="#val-visit_jmp" class="anchor"></a><code><span><span class="keyword">val</span> visit_jmp : <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Jmp.t <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Create a precondition for a given jump expression, depending on the postcondition and (potentially) the preconditions for the jump targets or the loop invariants.</p><p>We do not handle indirect jumps at all: we just return the current postcondition, which is unsound of course.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visit_elt" class="anchored"><a href="#val-visit_elt" class="anchor"></a><code><span><span class="keyword">val</span> visit_elt : <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Blk.elt <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Create a precondition for a given block element, which may be a jump, an assignment or a phi node. Depends on the postcondition, and the preconditions of other blocks or subroutines if the elt is a jump.</p><p>Note that we are not complete for phi nodes, and the Z3 semantics may be weaker than the BIR semantics.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visit_block" class="anchored"><a href="#val-visit_block" class="anchor"></a><code><span><span class="keyword">val</span> visit_block : <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Blk.t <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Create a precondition for a given block. Depends on the postcondition, and the preconditions of other blocks or subroutines if there is a jump.</p><p>Currently we do not handle loops very well, except by suppressing all back- edges in the CFG.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visit_sub" class="anchored"><a href="#val-visit_sub" class="anchor"></a><code><span><span class="keyword">val</span> visit_sub : <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Create a precondition for a given subroutine. Depends on the postcondition, and the preconditions of other blocks or subroutines if there is a jump.</p><p>Currently we do not handle loops very well, except by suppressing all back- edges in the CFG.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check" class="anchored"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : 
  <span>?refute:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?print_constr:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?debug:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?ext_solver:<span>(string * <span><span>(<span class="xref-unresolved">Z3</span>.FuncDecl.func_decl * <span class="xref-unresolved">Z3</span>.Symbol.symbol)</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?fmt:<span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Z3</span>.Solver.solver <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Z3</span>.Solver.status</span></code></div><div class="spec-doc"><p>Calls Z3 to check for a countermodel for the precondition of a BIR program. If refute is set to false, it checks for a model instead. If ~print_constr is called and contains &quot;smtlib&quot;, then Z3's solver (smt lib 2) will be printed. If ~debug is called and set to true, it will be passed to print statistics for Constr.eval inside this function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exclude" class="anchored"><a href="#val-exclude" class="anchor"></a><code><span><span class="keyword">val</span> exclude : 
  <span>?fmt:<span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Z3</span>.Solver.solver <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span>var:<a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span>pre:<a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Z3</span>.Solver.status</span></code></div><div class="spec-doc"><p>Adds a constraint to the Z3 solver in which var does not equal its value from the original Z3 model, then runs the Z3 solver again.</p><p>This has a side effect that updates the state of the solver. The solver's state can be reverted back with <code>Z3.Solver.pop</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_sp_range" class="anchored"><a href="#val-set_sp_range" class="anchor"></a><code><span><span class="keyword">val</span> set_sp_range : <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-t">Constr.t</a></span></code></div><div class="spec-doc"><p>Hypothesis that the stack pointer is within the valid range of the stack according to the environment.</p></div></div><p><code>construct_pointer_constraint</code> generates a constraint that the registers (passed in as z3 expressions) are treated as pointers. That is, all specified registers cannot point to the uninitalized stack region. They must be either below the bottom of the stack or above the initial stack pointer.</p><div class="odoc-spec"><div class="spec value" id="val-construct_pointer_constraint" class="anchored"><a href="#val-construct_pointer_constraint" class="anchor"></a><code><span><span class="keyword">val</span> construct_pointer_constraint : 
  <span><span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> list</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Environment/index.html#type-t">Env.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-t">Constr.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-loop_unroll" class="anchored"><a href="#val-loop_unroll" class="anchor"></a><code><span><span class="keyword">val</span> loop_unroll : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../Environment/index.html#type-loop_handler">Env.loop_handler</a></span></code></div><div class="spec-doc"><p><code>loop_unroll num_unroll</code> returns a function that will compute the precondition of nodes within loops by assuming that the loop was traversed at most <code>num_unroll</code> times. This is the default loop handler.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-loop_invariant_checker" class="anchored"><a href="#val-loop_invariant_checker" class="anchor"></a><code><span><span class="keyword">val</span> loop_invariant_checker : 
  <span><a href="../Environment/index.html#type-loop_invariants">Env.loop_invariants</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Environment/index.html#type-loop_handler">Env.loop_handler</a> option</span></span></code></div><div class="spec-doc"><p><code>loop_invariant_checker invariants tid</code> returns a function that will check the loop invariant for the loop that starts at <code>tid</code> given that the invariant exists in <code>invariants</code>.</p></div></div></div></body></html>