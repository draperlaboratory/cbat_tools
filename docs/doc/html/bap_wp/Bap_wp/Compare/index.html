<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Compare (bap_wp.Bap_wp.Compare)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">bap_wp</a> &#x00BB; <a href="../index.html">Bap_wp</a> &#x00BB; Compare</nav><header class="odoc-preamble"><h1>Module <code><span>Bap_wp.Compare</span></code></h1></header><div class="odoc-content"><p>This module creates utilities to create preconditions for comparing BIR blocks and subroutines.</p><p>Usage typically involves creating a new (abstract) <a href="../Environment/index.html#type-t"><code>Environment.t</code></a> value, a Z3 context and a <a href="../Environment/index.html#type-var_gen"><code>Environment.var_gen</code></a> using the utility functions.</p><p>The API returns a pair of <a href="#type-comparator"><code>comparator</code></a>s which are used to create a postcondition and hypothesis in that order. These should then be passed into <a href="#val-compare_subs"><code>compare_subs</code></a> in order to run the comparative analysis.</p><p>The resulting precondition can then be tested for satisfiability or provability using the Z3 Solver module using the <code>precondition</code> module utilities.</p><div class="odoc-spec"><div class="spec module" id="module-Env" class="anchored"><a href="#module-Env" class="anchor"></a><code><span><span class="keyword">module</span> Env</span><span> = <a href="../Environment/index.html">Environment</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Constr" class="anchored"><a href="#module-Constr" class="anchor"></a><code><span><span class="keyword">module</span> Constr</span><span> = <a href="../Constraint/index.html">Constraint</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-code" class="anchored"><a href="#type-code" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a code</span></span><span> = </span><span>{</span></code><table><tr id="type-code.prog" class="anchored"><td class="def record field"><a href="#type-code.prog" class="anchor"></a><code><span>prog : <span><span class="type-var">'a</span> <span class="xref-unresolved">Bap</span>.Std.term</span>;</span></code></td></tr><tr id="type-code.env" class="anchored"><td class="def record field"><a href="#type-code.env" class="anchor"></a><code><span>env : <a href="../Environment/index.html#type-t">Env.t</a>;</span></code></td></tr><tr id="type-code.mem" class="anchored"><td class="def record field"><a href="#type-code.mem" class="anchor"></a><code><span>mem : <span><span class="xref-unresolved">Bap</span>.Std.value <span class="xref-unresolved">Bap</span>.Std.memmap</span>;</span></code></td></tr><tr id="type-code.code_addrs" class="anchored"><td class="def record field"><a href="#type-code.code_addrs" class="anchor"></a><code><span>code_addrs : <a href="../Utils/Code_addrs/index.html#type-t">Utils.Code_addrs.t</a>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The data which encodes a piece of code, along with additional things associated with it, e.g. the CBAT environment and static memory data.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-comparator" class="anchored"><a href="#type-comparator" class="anchor"></a><code><span><span class="keyword">type</span> comparator</span></code></div><div class="spec-doc"><p>The type of functions that generate a postcondition or hypothesis for comparative analysis. Also updates the environments as needed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_blocks" class="anchored"><a href="#val-compare_blocks" class="anchor"></a><code><span><span class="keyword">val</span> compare_blocks : 
  <span>pre_regs:<span class="xref-unresolved">Bap</span>.Std.Var.Set.t <span class="arrow">&#45;&gt;</span></span>
  <span>post_regs:<span class="xref-unresolved">Bap</span>.Std.Var.Set.t <span class="arrow">&#45;&gt;</span></span>
  <span>original:<span><span class="xref-unresolved">Bap</span>.Std.blk <a href="#type-code">code</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>modified:<span><span class="xref-unresolved">Bap</span>.Std.blk <a href="#type-code">code</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>smtlib_post:string <span class="arrow">&#45;&gt;</span></span>
  <span>smtlib_hyp:string <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Compare two blocks by composition: Given a set of register values at pre-execution and a set of register values at post-execution, return a precondition which is provable only if (modulo soundness bugs) the registers at post-execution will have equal values given the registers at pre-execution have equal values.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs" class="anchored"><a href="#val-compare_subs" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs : 
  <span>postconds:<span><a href="#type-comparator">comparator</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>hyps:<span><a href="#type-comparator">comparator</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>original:<span><span class="xref-unresolved">Bap</span>.Std.sub <a href="#type-code">code</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>modified:<span><span class="xref-unresolved">Bap</span>.Std.sub <a href="#type-code">code</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></span></code></div><div class="spec-doc"><p>Compare two subroutines by composition: given the lists of postconditions and hypotheses generated by the API below.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs_eq" class="anchored"><a href="#val-compare_subs_eq" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs_eq : 
  <span>pre_regs:<span class="xref-unresolved">Bap</span>.Std.Var.Set.t <span class="arrow">&#45;&gt;</span></span>
  <span>post_regs:<span class="xref-unresolved">Bap</span>.Std.Var.Set.t <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-comparator">comparator</a> * <a href="#type-comparator">comparator</a></span></code></div><div class="spec-doc"><p>Compare two subroutines by composition for equality of return values:</p><p>Given a set of register values at pre-execution and a set of register values at post-execution, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) the registers at post-execution will have equal values given the registers at pre-execution have equal values.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs_empty" class="anchored"><a href="#val-compare_subs_empty" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs_empty : <a href="#type-comparator">comparator</a> * <a href="#type-comparator">comparator</a></span></code></div><div class="spec-doc"><p>Compare two subroutines by composition for an empty postcondition:</p><p>Given two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) the VCs generated by the hooks provided by the environment are satisfied.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs_empty_post" class="anchored"><a href="#val-compare_subs_empty_post" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs_empty_post : <a href="#type-comparator">comparator</a> * <a href="#type-comparator">comparator</a></span></code></div><div class="spec-doc"><p>Compare two subroutines by composition for an empty postcondition:</p><p>Given two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs), for equal inputs, the VCs generated by the hooks provided by the environment are satisfied.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs_sp" class="anchored"><a href="#val-compare_subs_sp" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs_sp : <a href="#type-comparator">comparator</a> * <a href="#type-comparator">comparator</a></span></code></div><div class="spec-doc"><p>Compare two subs by composition for an empty postcondition:</p><p>Give two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) the VCs generated by the hooks provided by the environment are satisfied. The hypothesis comparator generates a constraint which states that the stack pointer is within the bounds of the memory region we define with <code>Env.mk_env ~stack_range</code> at environment creation time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs_constraints" class="anchored"><a href="#val-compare_subs_constraints" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs_constraints : 
  <span>pre_conds:<a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>post_conds:<a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-comparator">comparator</a> * <a href="#type-comparator">comparator</a></span></code></div><div class="spec-doc"><p>Given a constraint to use as the hypothesis (precondition) and a constraint to use as the postcondition, returns a tuple of comparators. The first comparator returns the input postcondition constraint when called. The second comparator returns the input precondition constraint when called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs_fun" class="anchored"><a href="#val-compare_subs_fun" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs_fun : <a href="#type-comparator">comparator</a> * <a href="#type-comparator">comparator</a></span></code></div><div class="spec-doc"><p>Compare two subroutines by composition for conservation of function calls:</p><p>Given two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) every call made by the original subroutine is made by the modified one, given equal variables on input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs_smtlib" class="anchored"><a href="#val-compare_subs_smtlib" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs_smtlib : 
  <span>smtlib_post:string <span class="arrow">&#45;&gt;</span></span>
  <span>smtlib_hyp:string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-comparator">comparator</a> * <a href="#type-comparator">comparator</a></span></code></div><div class="spec-doc"><p>Compare two subroutines by composition based on the postcondition specified from the smtlib2 string.</p><p>Give two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) the postcondition from the smtlib2 string is satisfiable, given the hypothesis specified from the smtlib2 string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs_mem_eq" class="anchored"><a href="#val-compare_subs_mem_eq" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs_mem_eq : <a href="#type-comparator">comparator</a> * <a href="#type-comparator">comparator</a></span></code></div><div class="spec-doc"><p>Compare two subroutines by composition for an empty postcondition with the hypothesis that memory between the two binaries are equal at the beginning of the subroutines.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subs_mem_init" class="anchored"><a href="#val-compare_subs_mem_init" class="anchor"></a><code><span><span class="keyword">val</span> compare_subs_mem_init : <a href="#type-comparator">comparator</a> * <a href="#type-comparator">comparator</a></span></code></div><div class="spec-doc"><p>Compare two subroutines by composition for an empty postcondition, with the hypothesis that the memory at each offset in the .rodata section is assigned to the value given in the concrete binary.</p></div></div></div></body></html>