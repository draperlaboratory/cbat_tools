<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Compare (bap_wp.Bap_wp.Compare)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">bap_wp</a> &#x00BB; <a href="../index.html">Bap_wp</a> &#x00BB; Compare</nav><h1>Module <code>Bap_wp.Compare</code></h1></header><aside><p>This module creates utilities to create preconditions for comparing BIR blocks and subroutines.</p><p>Usage typically involves creating a new (abstract) <a href="../Environment/index.html#type-t"><code>Environment.t</code></a> value, a Z3 context and a <a href="../Environment/index.html#type-var_gen"><code>Environment.var_gen</code></a> using the utility functions.</p><p>The API returns a pair of <a href="index.html#type-comparator"><code>comparator</code></a>s which are used to create a postcondition and hypothesis in that order. These should then be passed into <a href="index.html#val-compare_subs"><code>compare_subs</code></a> in order to run the comparative analysis.</p><p>The resulting precondition can then be tested for satisfiability or provability using the Z3 Solver module using the <code>precondition</code> module utilities.</p></aside><div class="spec module" id="module-Env"><a href="#module-Env" class="anchor"></a><code><span class="keyword">module</span> Env = <a href="../index.html#module-Environment">Environment</a></code></div><div class="spec module" id="module-Constr"><a href="#module-Constr" class="anchor"></a><code><span class="keyword">module</span> Constr = <a href="../index.html#module-Constraint">Constraint</a></code></div><dl><dt class="spec type" id="type-comparator"><a href="#type-comparator" class="anchor"></a><code><span class="keyword">type</span> comparator</code></dt><dd><p>The type of functions that generate a postcondition or hypothesis for comparative analysis. Also updates the environments as needed.</p></dd></dl><dl><dt class="spec value" id="val-compare_blocks"><a href="#val-compare_blocks" class="anchor"></a><code><span class="keyword">val</span> compare_blocks : <span>pre_regs:Bap.Std.Var.Set.t</span> <span>&#45;&gt;</span> <span>post_regs:Bap.Std.Var.Set.t</span> <span>&#45;&gt;</span> <span>original:<span>(Bap.Std.Blk.t * <a href="../Environment/index.html#type-t">Env.t</a>)</span></span> <span>&#45;&gt;</span> <span>modified:<span>(Bap.Std.Blk.t * <a href="../Environment/index.html#type-t">Env.t</a>)</span></span> <span>&#45;&gt;</span> <span>smtlib_post:string</span> <span>&#45;&gt;</span> <span>smtlib_hyp:string</span> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Compare two blocks by composition: Given a set of register values at pre-execution and a set of register values at post-execution, return a precondition which is provable only if (modulo soundness bugs) the registers at post-execution will have equal values given the registers at pre-execution have equal values.</p></dd></dl><dl><dt class="spec value" id="val-compare_subs"><a href="#val-compare_subs" class="anchor"></a><code><span class="keyword">val</span> compare_subs : <span>postconds:<span><a href="index.html#type-comparator">comparator</a> list</span></span> <span>&#45;&gt;</span> <span>hyps:<span><a href="index.html#type-comparator">comparator</a> list</span></span> <span>&#45;&gt;</span> <span>original:<span>(Bap.Std.Sub.t * <a href="../Environment/index.html#type-t">Env.t</a>)</span></span> <span>&#45;&gt;</span> <span>modified:<span>(Bap.Std.Sub.t * <a href="../Environment/index.html#type-t">Env.t</a>)</span></span> <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="../Environment/index.html#type-t">Env.t</a> * <a href="../Environment/index.html#type-t">Env.t</a></code></dt><dd><p>Compare two subroutines by composition: given the lists of postconditions and hypotheses generated by the API below.</p></dd></dl><dl><dt class="spec value" id="val-compare_subs_eq"><a href="#val-compare_subs_eq" class="anchor"></a><code><span class="keyword">val</span> compare_subs_eq : <span>pre_regs:Bap.Std.Var.Set.t</span> <span>&#45;&gt;</span> <span>post_regs:Bap.Std.Var.Set.t</span> <span>&#45;&gt;</span> <a href="index.html#type-comparator">comparator</a> * <a href="index.html#type-comparator">comparator</a></code></dt><dd><p>Compare two subroutines by composition for equality of return values:</p><p>Given a set of register values at pre-execution and a set of register values at post-execution, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) the registers at post-execution will have equal values given the registers at pre-execution have equal values.</p></dd></dl><dl><dt class="spec value" id="val-compare_subs_empty"><a href="#val-compare_subs_empty" class="anchor"></a><code><span class="keyword">val</span> compare_subs_empty : <a href="index.html#type-comparator">comparator</a> * <a href="index.html#type-comparator">comparator</a></code></dt><dd><p>Compare two subroutines by composition for an empty postcondition:</p><p>Given two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) the VCs generated by the hooks provided by the environment are satisfied.</p></dd></dl><dl><dt class="spec value" id="val-compare_subs_empty_post"><a href="#val-compare_subs_empty_post" class="anchor"></a><code><span class="keyword">val</span> compare_subs_empty_post : <a href="index.html#type-comparator">comparator</a> * <a href="index.html#type-comparator">comparator</a></code></dt><dd><p>Compare two subroutines by composition for an empty postcondition:</p><p>Given two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs), for equal inputs, the VCs generated by the hooks provided by the environment are satisfied.</p></dd></dl><dl><dt class="spec value" id="val-compare_subs_sp"><a href="#val-compare_subs_sp" class="anchor"></a><code><span class="keyword">val</span> compare_subs_sp : <a href="index.html#type-comparator">comparator</a> * <a href="index.html#type-comparator">comparator</a></code></dt><dd><p>Compare two subs by composition for an empty postcondition:</p><p>Give two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) the VCs generated by the hooks provided by the environment are satisfied, given that the architecture of the binary is x86_64. The hypothesis comparator generates a constraint which states that the stack pointer is within the bounds of the memory region we define with <code>Env.mk_env ~stack_range</code> at environment creation time.</p></dd></dl><dl><dt class="spec value" id="val-compare_subs_fun"><a href="#val-compare_subs_fun" class="anchor"></a><code><span class="keyword">val</span> compare_subs_fun : <a href="index.html#type-comparator">comparator</a> * <a href="index.html#type-comparator">comparator</a></code></dt><dd><p>Compare two subroutines by composition for conservation of function calls:</p><p>Given two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) every call made by the original subroutine is made by the modified one, given equal variables on input.</p></dd></dl><dl><dt class="spec value" id="val-compare_subs_smtlib"><a href="#val-compare_subs_smtlib" class="anchor"></a><code><span class="keyword">val</span> compare_subs_smtlib : <span>smtlib_post:string</span> <span>&#45;&gt;</span> <span>smtlib_hyp:string</span> <span>&#45;&gt;</span> <a href="index.html#type-comparator">comparator</a> * <a href="index.html#type-comparator">comparator</a></code></dt><dd><p>Compare two subroutines by composition based on the postcondition specified from the smtlib2 string.</p><p>Give two subroutines and environments, return a postcondition and hypothesis that, when passed to <code>compare_subs</code>, will generate a precondition which is provable only if (modulo soundness bugs) the postcondition from the smtlib2 string is satisfiable, given the hypothesis specified from the smtlib2 string.</p></dd></dl><dl><dt class="spec value" id="val-mk_smtlib2_compare"><a href="#val-mk_smtlib2_compare" class="anchor"></a><code><span class="keyword">val</span> mk_smtlib2_compare : <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Environment/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Constraint/index.html#type-t">Constr.t</a></code></dt><dd><p><code>mk_smtlib2_compare</code> builds a constraint out of an smtlib2 string that can be used as a comparison predicate between an original and modified binary.</p></dd></dl></div></body></html>