<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Environment (bap_wp.Bap_wp.Environment)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">bap_wp</a> &#x00BB; <a href="../index.html">Bap_wp</a> &#x00BB; Environment</nav><header class="odoc-preamble"><h1>Module <code><span>Bap_wp.Environment</span></code></h1><p>This module represents the environment of a BIR program and is used when determining pre-conditions.</p><p>It contains a Z3 context, a <a href="#type-var_gen"><code>var_gen</code></a>, the association between BIR variables and Z3 constants, preconditions for previously visited blocks, a mapping of Z3 variables to function calls during runtime, subroutine summaries, a handler for loop unrolling, and expression verification conditions.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-EnvMap" class="anchored"><a href="#module-EnvMap" class="anchor"></a><code><span><span class="keyword">module</span> EnvMap</span><span> = <span class="xref-unresolved">Bap</span>.Std.Var.Map</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Constr" class="anchored"><a href="#module-Constr" class="anchor"></a><code><span><span class="keyword">module</span> Constr</span><span> = <a href="../Constraint/index.html">Constraint</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-ExprSet" class="anchored"><a href="#module-ExprSet" class="anchor"></a><code><span><span class="keyword">module</span> ExprSet</span><span> : <span class="xref-unresolved">Core</span>.Set.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">Elt.t</span> = <span class="xref-unresolved">Constr</span>.z3_expr</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Unroll_depth" class="anchored"><a href="#module-Unroll_depth" class="anchor"></a><code><span><span class="keyword">module</span> Unroll_depth</span><span> = <span class="xref-unresolved">Bap</span>.Std.Blk.Map</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The state type which is maintained when creating preconditions. It contains, among other things, summaries for subroutines, the associations between BIR variables and Z3 constants, and preconditions for already visited blocks, if relevant.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-var_gen" class="anchored"><a href="#type-var_gen" class="anchor"></a><code><span><span class="keyword">type</span> var_gen</span></code></div><div class="spec-doc"><p>This type is used to create fresh variables when needed. It's internals should be irrelevant.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-fun_spec_type" class="anchored"><a href="#type-fun_spec_type" class="anchor"></a><code><span><span class="keyword">type</span> fun_spec_type</span><span> = </span></code><table><tr id="type-fun_spec_type.Summary" class="anchored"><td class="def variant constructor"><a href="#type-fun_spec_type.Summary" class="anchor"></a><code><span>| </span><span><span class="constructor">Summary</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="#type-t">t</a></span></code></td></tr><tr id="type-fun_spec_type.Inline" class="anchored"><td class="def variant constructor"><a href="#type-fun_spec_type.Inline" class="anchor"></a><code><span>| </span><span><span class="constructor">Inline</span></span></code></td></tr></table></div><div class="spec-doc"><p>The type that specifies whether a fun_spec should calculate the precondition based off a summary or by inlining the function and visiting it with <a href="../Precondition/index.html#val-visit_sub"><code>Precondition.visit_sub</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-fun_spec" class="anchored"><a href="#type-fun_spec" class="anchor"></a><code><span><span class="keyword">type</span> fun_spec</span><span> = </span><span>{</span></code><table><tr id="type-fun_spec.spec_name" class="anchored"><td class="def record field"><a href="#type-fun_spec.spec_name" class="anchor"></a><code><span>spec_name : string;</span></code></td></tr><tr id="type-fun_spec.spec" class="anchored"><td class="def record field"><a href="#type-fun_spec.spec" class="anchor"></a><code><span>spec : <a href="#type-fun_spec_type">fun_spec_type</a>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Type that specifies what rules should be used when calculating the precondition of a subroutine.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-indirect_spec" class="anchored"><a href="#type-indirect_spec" class="anchor"></a><code><span><span class="keyword">type</span> indirect_spec</span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Exp.t <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Type that specifies what rules should be used when encountering an indirect call</p></div></div><div class="odoc-spec"><div class="spec type" id="type-jmp_spec" class="anchored"><a href="#type-jmp_spec" class="anchor"></a><code><span><span class="keyword">type</span> jmp_spec</span><span> =
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Jmp.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="#type-t">t</a>)</span> option</span></span></code></div><div class="spec-doc"><p>Type that specifies what rules should be used when visiting a jump in a BIR program.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-int_spec" class="anchored"><a href="#type-int_spec" class="anchor"></a><code><span><span class="keyword">type</span> int_spec</span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Type that specifies what rules should be used when calculating the precondition of an interrupt.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-loop_handler" class="anchored"><a href="#type-loop_handler" class="anchor"></a><code><span><span class="keyword">type</span> loop_handler</span><span> =
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>start:<span class="xref-unresolved">Bap</span>.Std.Graphs.Ir.Node.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Graphs.Ir.t <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The loop handling procedure for the appropriate blocks.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-cond" class="anchored"><a href="#type-cond" class="anchor"></a><code><span><span class="keyword">type</span> cond</span><span> = </span></code><table><tr id="type-cond.BeforeExec" class="anchored"><td class="def variant constructor"><a href="#type-cond.BeforeExec" class="anchor"></a><code><span>| </span><span><span class="constructor">BeforeExec</span> <span class="keyword">of</span> <a href="../Constraint/index.html#type-goal">Constr.goal</a></span></code></td></tr><tr id="type-cond.AfterExec" class="anchored"><td class="def variant constructor"><a href="#type-cond.AfterExec" class="anchor"></a><code><span>| </span><span><span class="constructor">AfterExec</span> <span class="keyword">of</span> <a href="../Constraint/index.html#type-goal">Constr.goal</a></span></code></td></tr></table></div><div class="spec-doc"><p>Condition generated when exploring an expression: <code>BeforeExec</code> will generate a <a href="../Constraint/index.html#type-goal"><code>Constr.goal</code></a> to be added to the postcondition before any substitution is made, and <code>AfterExec</code> will generate the goal to be added after all substitutions are completed.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-cond_type" class="anchored"><a href="#type-cond_type" class="anchor"></a><code><span><span class="keyword">type</span> cond_type</span><span> = </span></code><table><tr id="type-cond_type.Verify" class="anchored"><td class="def variant constructor"><a href="#type-cond_type.Verify" class="anchor"></a><code><span>| </span><span><span class="constructor">Verify</span> <span class="keyword">of</span> <a href="#type-cond">cond</a></span></code></td></tr><tr id="type-cond_type.Assume" class="anchored"><td class="def variant constructor"><a href="#type-cond_type.Assume" class="anchor"></a><code><span>| </span><span><span class="constructor">Assume</span> <span class="keyword">of</span> <a href="#type-cond">cond</a></span></code></td></tr></table></div><div class="spec-doc"><p>Conditions generated when exploring an expression: if it is a <code>Verify</code>, this represents an additional proof obligation, an <code>Assume</code> represents an assumption, typically about the definedness of the expression.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-exp_cond" class="anchored"><a href="#type-exp_cond" class="anchor"></a><code><span><span class="keyword">type</span> exp_cond</span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Exp.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-cond_type">cond_type</a> option</span></span></code></div><div class="spec-doc"><p>Type that generates a Verification Condition on encountering a given pattern, typically a correctness constraint, like no overflow or no null dereference.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-mem_range" class="anchored"><a href="#type-mem_range" class="anchor"></a><code><span><span class="keyword">type</span> mem_range</span><span> = </span><span>{</span></code><table><tr id="type-mem_range.base_addr" class="anchored"><td class="def record field"><a href="#type-mem_range.base_addr" class="anchor"></a><code><span>base_addr : int;</span></code></td></tr><tr id="type-mem_range.size" class="anchored"><td class="def record field"><a href="#type-mem_range.size" class="anchor"></a><code><span>size : int;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-unroll_depth" class="anchored"><a href="#type-unroll_depth" class="anchor"></a><code><span><span class="keyword">type</span> unroll_depth</span><span> = <span>int <span class="xref-unresolved">Unroll_depth</span>.t</span></span></code></div><div class="spec-doc"><p>A map containing the current depth for a block when unrolling a loop.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-loop_invariants" class="anchored"><a href="#type-loop_invariants" class="anchor"></a><code><span><span class="keyword">type</span> loop_invariants</span><span> = <span>string <span class="xref-unresolved">Bap</span>.Std.Tid.Map.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-init_loop_handler" class="anchored"><a href="#val-init_loop_handler" class="anchor"></a><code><span><span class="keyword">val</span> init_loop_handler : 
  <span>default:<a href="#type-loop_handler">loop_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-loop_handler">loop_handler</a> option</span> )</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-loop_handler">loop_handler</a></span></code></div><div class="spec-doc"><p><code>init_loop_handler default handlers</code> takes in a list of handlers that will be used when visiting a loop in the subroutine. The handler used is based off of the loop's tid.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_env" class="anchored"><a href="#val-mk_env" class="anchor"></a><code><span><span class="keyword">val</span> mk_env : 
  <span>subs:<span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="xref-unresolved">Bap</span>.Std.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>specs:
    <span><span>( <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-fun_spec">fun_spec</a> option</span> )</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>default_spec:<span>( <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span> <a href="#type-fun_spec">fun_spec</a> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>indirect_spec:<a href="#type-indirect_spec">indirect_spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>jmp_spec:<a href="#type-jmp_spec">jmp_spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int_spec:<a href="#type-int_spec">int_spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>exp_conds:<span><a href="#type-exp_cond">exp_cond</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>loop_handlers:<span><span>( <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-loop_handler">loop_handler</a> option</span> )</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>default_loop_handler:<a href="#type-loop_handler">loop_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span>target:<span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span>
  <span>freshen_vars:bool <span class="arrow">&#45;&gt;</span></span>
  <span>use_fun_input_regs:bool <span class="arrow">&#45;&gt;</span></span>
  <span>stack_range:<a href="#type-mem_range">mem_range</a> <span class="arrow">&#45;&gt;</span></span>
  <span>data_section_range:<a href="#type-mem_range">mem_range</a> <span class="arrow">&#45;&gt;</span></span>
  <span>func_name_map:<span>string <span class="xref-unresolved">Core</span>.String.Map.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>smtlib_compat:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-var_gen">var_gen</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Creates a new environment with</p><ul><li>a sequence of subroutines in the program used to initialize function specs</li><li>a list of <a href="#type-fun_spec"><code>fun_spec</code></a>s that each summarize the precondition for its mapped function</li><li>the default fun_spec in the case a function does not satisfy the requirements of the other fun_specs</li><li>a <a href="#type-indirect_spec"><code>indirect_spec</code></a> for handling indirect calls</li><li>a <a href="#type-jmp_spec"><code>jmp_spec</code></a> for handling branches</li><li>an <a href="#type-int_spec"><code>int_spec</code></a> for handling interrupts</li><li>a list of <a href="#type-exp_cond"><code>exp_cond</code></a>s to satisfy</li><li>the number of times to unroll a loop</li><li>a loop handler that can unroll a loop or check a loop invariant</li><li>the target architecture of the binary</li><li>the option to freshen variable names</li><li>the option to use all input registers when generating function symbols at a call site</li><li>the concrete range of addresses of the stack</li><li>the concrete range of addresses of the data section</li><li>a Z3 context</li><li>and a variable generator.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-env_to_string" class="anchored"><a href="#val-env_to_string" class="anchor"></a><code><span><span class="keyword">val</span> env_to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Creates a string representation of the environment.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_ctx" class="anchored"><a href="#val-mk_ctx" class="anchor"></a><code><span><span class="keyword">val</span> mk_ctx : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Z3</span>.context</span></code></div><div class="spec-doc"><p>Create a Z3 context, used to generate every Z3 expression. Simply defined as <code>Z3.mk_context []</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_var_gen" class="anchored"><a href="#val-mk_var_gen" class="anchor"></a><code><span><span class="keyword">val</span> mk_var_gen : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-var_gen">var_gen</a></span></code></div><div class="spec-doc"><p>Create a new variable generator. Two fresh variables created with the same generator will be distinct.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_fresh" class="anchored"><a href="#val-get_fresh" class="anchor"></a><code><span><span class="keyword">val</span> get_fresh : <span>?name:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-var_gen">var_gen</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Get a fresh variable name, possibly prefixed by a given <code>name</code> string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_freshen" class="anchored"><a href="#val-set_freshen" class="anchor"></a><code><span><span class="keyword">val</span> set_freshen : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Set variable freshening, which will cause constraint generation to create fresh variables.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-freshen" class="anchored"><a href="#val-freshen" class="anchor"></a><code><span><span class="keyword">val</span> freshen : 
  <span>?name:<span>( <span>string <span class="arrow">&#45;&gt;</span></span> string )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Var.Set.t <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-t">Constr.t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>freshen ~name constr env vars</code> creates fresh names for <code>vars</code> found in <code>constr</code>. Optionally takes in <code>name</code>, which is a function that maps the original variable name to the fresh name. Defaults to <code>fresh_var</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_call_pred" class="anchored"><a href="#val-add_call_pred" class="anchor"></a><code><span><span class="keyword">val</span> add_call_pred : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Add a z3 expression representing a function call predicate generated during the analysis to the environment.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clear_call_preds" class="anchored"><a href="#val-clear_call_preds" class="anchor"></a><code><span><span class="keyword">val</span> clear_call_preds : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Removes all z3 expressions representing function call predicates from the environment. This is used because the initial pass through a binary generates predicates that are not used during precondition computation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_var" class="anchored"><a href="#val-add_var" class="anchor"></a><code><span><span class="keyword">val</span> add_var : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Var.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Add a new binding to the environment for a bap variable to a Z3 expression, typically a constant.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_var" class="anchored"><a href="#val-remove_var" class="anchor"></a><code><span><span class="keyword">val</span> remove_var : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Var.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Remove a binding in the environment for a bap variable.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_var" class="anchored"><a href="#val-find_var" class="anchor"></a><code><span><span class="keyword">val</span> find_var : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Var.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> option</span></span></code></div><div class="spec-doc"><p>Looks up the Z3 variable that represents a BIR variable.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_precond" class="anchored"><a href="#val-add_precond" class="anchor"></a><code><span><span class="keyword">val</span> add_precond : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Add a precondition to be associated to a block b to the environment.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_exp_conds" class="anchored"><a href="#val-mk_exp_conds" class="anchor"></a><code><span><span class="keyword">val</span> mk_exp_conds : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Exp.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-cond_type">cond_type</a> list</span></span></code></div><div class="spec-doc"><p>Creates a list of assumptions and verification conditions as hooks on an expression being visited during analysis.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_context" class="anchored"><a href="#val-get_context" class="anchor"></a><code><span><span class="keyword">val</span> get_context : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Z3</span>.context</span></code></div><div class="spec-doc"><p>Obtains the Z3 context within a given environment.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_var_gen" class="anchored"><a href="#val-get_var_gen" class="anchor"></a><code><span><span class="keyword">val</span> get_var_gen : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-var_gen">var_gen</a></span></code></div><div class="spec-doc"><p>Obtains the var_gen used to create fresh variables within a given environment.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_subs" class="anchored"><a href="#val-get_subs" class="anchor"></a><code><span><span class="keyword">val</span> get_subs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Sub.t <span class="xref-unresolved">Bap</span>.Std.Seq.t</span></span></code></div><div class="spec-doc"><p>Obtains the sequence of subroutines that belongs to a BIR program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_var_map" class="anchored"><a href="#val-get_var_map" class="anchor"></a><code><span><span class="keyword">val</span> get_var_map : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="xref-unresolved">EnvMap</span>.t</span></span></code></div><div class="spec-doc"><p>Obtains the var_map containing a mapping of BIR variables to Z3 variables.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_init_var_map" class="anchored"><a href="#val-get_init_var_map" class="anchor"></a><code><span><span class="keyword">val</span> get_init_var_map : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="xref-unresolved">EnvMap</span>.t</span></span></code></div><div class="spec-doc"><p>Obtains the var_map containing a mapping of BIR variables to the Z3 variables that represent their initial states.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_var" class="anchored"><a href="#val-get_var" class="anchor"></a><code><span><span class="keyword">val</span> get_var : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Var.t <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Looks up the Z3 variable that represents a BIR variable. Produces fresh z3_expr if not found.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_precondition" class="anchored"><a href="#val-get_precondition" class="anchor"></a><code><span><span class="keyword">val</span> get_precondition : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-t">Constr.t</a> option</span></span></code></div><div class="spec-doc"><p>Looks up the precondition for a given block in the environment. Currently returns True if the block is not yet visited.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_sub_name" class="anchored"><a href="#val-get_sub_name" class="anchor"></a><code><span><span class="keyword">val</span> get_sub_name : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p>Looks up the subroutine's name given its tid.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_fun_name_tid" class="anchored"><a href="#val-get_fun_name_tid" class="anchor"></a><code><span><span class="keyword">val</span> get_fun_name_tid : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Tid.t option</span></span></code></div><div class="spec-doc"><p>Finds the tid of a function in the environment.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_called" class="anchored"><a href="#val-get_called" class="anchor"></a><code><span><span class="keyword">val</span> get_called : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.tid <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p>Look up the string name for the variable which represents a call made to a subroutine with a given <code>tid</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_sub_handler" class="anchored"><a href="#val-get_sub_handler" class="anchor"></a><code><span><span class="keyword">val</span> get_sub_handler : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-fun_spec_type">fun_spec_type</a> option</span></span></code></div><div class="spec-doc"><p>Looks up the specification of a subroutine that is used to calculate the precondition of a function call.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_indirect_handler" class="anchored"><a href="#val-get_indirect_handler" class="anchor"></a><code><span><span class="keyword">val</span> get_indirect_handler : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Exp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-indirect_spec">indirect_spec</a></span></code></div><div class="spec-doc"><p>Looks up the indirect call spec for an expression. Used to calculate the precondition of an indirect call.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_jmp_handler" class="anchored"><a href="#val-get_jmp_handler" class="anchor"></a><code><span><span class="keyword">val</span> get_jmp_handler : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-jmp_spec">jmp_spec</a></span></code></div><div class="spec-doc"><p>Looks up the list of jmp_specs that is used to calculate the precondition of jumps in a BIR program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_jmp_handler" class="anchored"><a href="#val-set_jmp_handler" class="anchor"></a><code><span><span class="keyword">val</span> set_jmp_handler : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-jmp_spec">jmp_spec</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Updates the list of jmp_specs used to calculate the precondition of jumps in a BIR program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int_handler" class="anchored"><a href="#val-get_int_handler" class="anchor"></a><code><span><span class="keyword">val</span> get_int_handler : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-int_spec">int_spec</a></span></code></div><div class="spec-doc"><p>Looks up the specification of calculating the precondition of an interrupt.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_loop_handler" class="anchored"><a href="#val-get_loop_handler" class="anchor"></a><code><span><span class="keyword">val</span> get_loop_handler : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Constraint/index.html#type-t">Constr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>start:<span class="xref-unresolved">Bap</span>.Std.Graphs.Ir.Node.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bap</span>.Std.Graphs.Ir.t <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Finds the <a href="#type-loop_handler"><code>loop_handler</code></a> that is used to unroll loops when it is visited in the BIR program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_target" class="anchored"><a href="#val-get_target" class="anchor"></a><code><span><span class="keyword">val</span> get_target : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Bap_core_theory</span>.Theory.target</span></code></div><div class="spec-doc"><p>Obtains the target architecture of the program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_gprs" class="anchored"><a href="#val-get_gprs" class="anchor"></a><code><span><span class="keyword">val</span> get_gprs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Bap</span>.Std.Var.Set.t</span></code></div><div class="spec-doc"><p>Obtains the general purpose registers of the target architecture of the program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_sp" class="anchored"><a href="#val-get_sp" class="anchor"></a><code><span><span class="keyword">val</span> get_sp : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Bap</span>.Std.Var.t</span></code></div><div class="spec-doc"><p>Obtains the name of the program's stack pointer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_mem" class="anchored"><a href="#val-get_mem" class="anchor"></a><code><span><span class="keyword">val</span> get_mem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Bap</span>.Std.Var.t</span></code></div><div class="spec-doc"><p>Obtains the BAP variable representing a program's memory.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_all_target_vars" class="anchored"><a href="#val-get_all_target_vars" class="anchor"></a><code><span><span class="keyword">val</span> get_all_target_vars : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Bap</span>.Std.Var.Set.t</span></code></div><div class="spec-doc"><p>Obtain the set of all registers and memories for the target.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_call_preds" class="anchored"><a href="#val-get_call_preds" class="anchor"></a><code><span><span class="keyword">val</span> get_call_preds : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">ExprSet</span>.t</span></code></div><div class="spec-doc"><p>Obtains a list of all the <a href="../Constraint/index.html#type-z3_expr"><code>Constr.z3_expr</code></a>s that represents function call predicates that were generated during analysis.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_fun_tids" class="anchored"><a href="#val-fold_fun_tids" class="anchor"></a><code><span><span class="keyword">val</span> fold_fun_tids : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>init:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>( <span>key:string <span class="arrow">&#45;&gt;</span></span> <span>data:<span class="xref-unresolved">Bap</span>.Std.Tid.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Performs a fold on the map of of function names to tids to generate a <a href="../Constraint/index.html#type-z3_expr"><code>Constr.z3_expr</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_x86" class="anchored"><a href="#val-is_x86" class="anchor"></a><code><span><span class="keyword">val</span> is_x86 : <span><span class="xref-unresolved">Bap_core_theory</span>.Theory.target <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Checks if the target is part of the x86 family.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-use_input_regs" class="anchored"><a href="#val-use_input_regs" class="anchor"></a><code><span><span class="keyword">val</span> use_input_regs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Checks to see if the environment supports using all possible input registers when generating symbols in the function specs at a function call site.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_smtlib_compat" class="anchored"><a href="#val-get_smtlib_compat" class="anchor"></a><code><span><span class="keyword">val</span> get_smtlib_compat : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Determine whether to generate constraints that are smtlib compatible or using optimizations that are Z3 specific. Put to <code>true</code> if using external smt solver</p></div></div><div class="odoc-spec"><div class="spec value" id="val-in_stack" class="anchored"><a href="#val-in_stack" class="anchor"></a><code><span><span class="keyword">val</span> in_stack : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p><code>in_stack env addr</code> is the constraint <code>STACK_MIN &lt; addr &lt;= STACK_MAX</code> as defined by the concrete range of the stack in the env.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_stack_end" class="anchored"><a href="#val-get_stack_end" class="anchor"></a><code><span><span class="keyword">val</span> get_stack_end : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_stack_end</code> retrieves the address of the largest address that the top of the stack can take. It is assumed the stack grows downwards, from high addresss to low address. The top and start of the stack is defined as stack_base and is the largest address in the stack. The stack end (retrieved by this function) is the smallest value that the stack pointer can take.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-in_data_section" class="anchored"><a href="#val-in_data_section" class="anchor"></a><code><span><span class="keyword">val</span> in_data_section : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p><code>in_data_section env addr</code> is the constraint <code>DATA_MIN &lt;= addr &lt; DATA_MAX</code> as defined by the concrete range of the data section in the env.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init_stack_ptr" class="anchored"><a href="#val-init_stack_ptr" class="anchor"></a><code><span><span class="keyword">val</span> init_stack_ptr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p><code>init_stack_ptr env ptr</code> initializes the constraint <code>STACK_MIN + 128 &lt; sp &lt;= STACK_MAX</code> which is the region of the stack that the stack pointer may point to at the beginning of a subroutine. The 128 is based off of the 128 bytes of red zone underneath the stack pointer in x86_64.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-update_stack_base" class="anchored"><a href="#val-update_stack_base" class="anchor"></a><code><span><span class="keyword">val</span> update_stack_base : <span><a href="#type-mem_range">mem_range</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-mem_range">mem_range</a></span></code></div><div class="spec-doc"><p><code>update_stack_base range base</code> updates the highest address of the stack to be the same value as base.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-update_stack_size" class="anchored"><a href="#val-update_stack_size" class="anchor"></a><code><span><span class="keyword">val</span> update_stack_size : <span><a href="#type-mem_range">mem_range</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-mem_range">mem_range</a></span></code></div><div class="spec-doc"><p><code>update_stack_size range size</code> updates the size of the stack to be the same value as size.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_init_var" class="anchored"><a href="#val-mk_init_var" class="anchor"></a><code><span><span class="keyword">val</span> mk_init_var : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Var.t <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>mk_init_var env var</code> creates a fresh Z3 variable that represents the initial state of variable <code>var</code>. Adds a new binding to <code>env</code> for the bap variable to is generated init variable.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_init_var" class="anchored"><a href="#val-get_init_var" class="anchor"></a><code><span><span class="keyword">val</span> get_init_var : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Var.t <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a> option</span></span></code></div><div class="spec-doc"><p><code>get_init_var var</code> obtains the Z3 expression that represents the initial state of a bap variable <code>var</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_sub_name" class="anchored"><a href="#val-map_sub_name" class="anchor"></a><code><span><span class="keyword">val</span> map_sub_name : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>map_sub_name env name_mod</code> obtains the name of the subroutine in the original binary based off its name in the modified binary. In the case there is no mapping for the subroutine, <code>get_sub_name</code> will return <code>name_mod</code> (when calling this function from the original binary.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_unroll_depth" class="anchored"><a href="#val-get_unroll_depth" class="anchor"></a><code><span><span class="keyword">val</span> get_unroll_depth : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Blk.t <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>get_unroll_depth env node</code> obtains the unroll depth for <code>node</code> when unrolling a loop.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_unroll_depth" class="anchored"><a href="#val-set_unroll_depth" class="anchor"></a><code><span><span class="keyword">val</span> set_unroll_depth : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Blk.t <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span>int option</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>set_unroll_depth env node depth</code> updates the map with the new unroll depth for <code>node</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_z3_expr" class="anchored"><a href="#val-mk_z3_expr" class="anchor"></a><code><span><span class="keyword">val</span> mk_z3_expr : 
  <span><span class="xref-unresolved">Z3</span>.context <span class="arrow">&#45;&gt;</span></span>
  <span>name:string <span class="arrow">&#45;&gt;</span></span>
  <span>typ:<span class="xref-unresolved">Bap</span>.Std.Type.t <span class="arrow">&#45;&gt;</span></span>
  <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Create a constant Z3 expression of a type that corresponds to a bap type, where the correspondence is as follows:</p><ul><li>BitVector of width <code>w</code> -&gt; BitVector of width <code>w</code></li><li>Memory value with address size <code>a</code> and word size <code>w</code> -&gt; Functional array from BitVector <code>a</code> to BitVector <code>w</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-new_z3_expr" class="anchored"><a href="#val-new_z3_expr" class="anchor"></a><code><span><span class="keyword">val</span> new_z3_expr : <span>?name:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bap</span>.Std.Type.t <span class="arrow">&#45;&gt;</span></span> <a href="../Constraint/index.html#type-z3_expr">Constr.z3_expr</a></span></code></div><div class="spec-doc"><p>Create a Z3 constant of the appropriate name and type, but ensure that the constant is &quot;fresh&quot; with the <a href="#type-var_gen"><code>Environment.var_gen</code></a>.</p></div></div></div></body></html>